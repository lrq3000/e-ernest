package imos;


import imos2.IInteraction;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import ernest.ITracer;

/**
 * The Intrinsically Motivated Schema mechanism.
 * @author ogeorgeon
 */

public class Imos implements IImos 
{	
	/** Default regularity sensibility threshold (The weight threshold for an act to become reliable). */
	public final int REG_SENS_THRESH = 6;

	/** Default maximum length of a schema (For the schema to be chosen as an intention) */
	public final int SCHEMA_MAX_LENGTH = 100;

	/** Default Activation threshold (The weight threshold for higher-level learning with the second learning mechanism). */
	public final int ACTIVATION_THRESH = 1;

	/** Hypothetical act (Cannot be chosen as an intention, cannot support higher-level learning). */
	public static final int HYPOTHETICAL = 1;

	/** Reliable act (Can be chosen as an intention and can support higher-level learning). */
	public static final int RELIABLE = 2;
	
	/** Regularity sensibility threshold (The weight threshold for an act to become reliable). */
	private int m_regularitySensibilityThreshold;

	/** A list of all the schemas ever created ... */
	private ArrayList<ISchema> m_schemas = new ArrayList<ISchema>(1000);

	/** A list of all the acts ever created. */
	private ArrayList<IAct> m_acts = new ArrayList<IAct>(2000);
	
	/** A list of all the acts ever created. Aimed to replace schemas and acts*/
	private ArrayList<IInteraction> m_interactions = new ArrayList<IInteraction>(2000);
	
	/** If true then the IMOS does not use random */
	public static boolean DETERMINISTIC = true; 

	/** Counter of learned schemas for tracing */
	private int m_nbSchemaLearned = 0;
	
	/** The Tracer. */
	private ITracer<Object> m_tracer = null; //new Tracer("trace.txt");

	/** A representation of the internal state for display in the environment. */
	private String m_internalState = "";
	
	/** Random generator used to break a tie when selecting a schema... */
	//private static Random m_rand = new Random(); 
	
	/** Counter of cognitive cycles. */
	private int m_imosCycle = 0;
	
	/**
	 * Constructor for the Intrinsic Motivation system.
	 * Use default parameters REG_SENS_THRESH and SCHEMA_MAX_LENGTH.
	 */
	public Imos()
	{
		m_regularitySensibilityThreshold = REG_SENS_THRESH;
	}
	
	public void setRegularityThreshold(int regularityThreshold)
	{
		m_regularitySensibilityThreshold = regularityThreshold;
	}
	
	/**
	 * Constructor for the Intrinsic Motivation system.
	 * @param regularitySensibilityThreshold  The regularity sensibility threshold.
	 * A lower value favors the faster adoption of possibly less satisfying sequences, 
	 * a higher value favors the slower adoption of possibly more satisfying sequences.
	 */
	public Imos(int regularitySensibilityThreshold)
	{
		m_regularitySensibilityThreshold = regularitySensibilityThreshold;
	}

	/**
	 * @param tracer The tracer.
	 */
	public void setTracer(ITracer<Object> tracer)
	{
		m_tracer = tracer;
	}
	
	/**
	 * Get a string description of the imos's internal state for display in the environment.
	 * @return A representation of the imos's internal state
	 */
	public String getInternalState()
	{
		return m_internalState;
	}

	/**
	 * Construct a new interaction or retrieve the interaction if it already exists.
	 * The interaction's action is recorded as a primitive schema.
	 * @param moveLabel The label of the interaction's action in the environment.
	 * @param effectLabel The label of the interaction's stimuli generated by the action.
	 * @param satisfaction The interaction's satisfaction (only needed in case this interaction was not 
	 * yet declared in imos).
	 * @return The act that was created or that already existed.
	 */
	public IAct addInteraction(String moveLabel, String effectLabel, int satisfaction)
	{
		ISchema s =  addPrimitiveSchema(moveLabel);
		
		// Primitive satisfactions are multiplied by 10 internally for rounding issues.   
		// (this value does not impact the agent's behavior)
		IAct a = Act.createPrimitiveAct(moveLabel, effectLabel, s, satisfaction * 10);
		
		int i = m_acts.indexOf(a);
		if (i == -1)
			// The act does not exist
			m_acts.add(a);
		else 
			// The act already exists: return a pointer to it.
			a =  m_acts.get(i);
		
		System.out.println("Primitive interaction " + a.toString() + " " + a.getSatisfaction());
		return a;		
	}

	/**
	 * Add a primitive schema 
	 * @param label The schema's string identifier.
	 * @return The created primitive schema.
	 */
	private ISchema addPrimitiveSchema(String label) 
	{
		ISchema s =  Schema.createPrimitiveSchema(m_schemas.size() + 1, label);
		int i = m_schemas.indexOf(s);
		if (i == -1)
			m_schemas.add(s);
		else
			// The schema already exists: return a pointer to it.
			s =  m_schemas.get(i);
    	return s;
	}

	/**
	 * Track the current enaction. 
	 * Use the intended primitive act and the effect.
	 * Generates the enacted primitive act, the top enacted act, and the top remaining act.
	 * @param enaction The current enaction.
	 */
	public void track(IEnaction enaction) 
	{
		m_imosCycle++;		
		
		IAct intendedPrimitiveAct = enaction.getIntendedPrimitiveAct();
		IAct enactedPrimitiveAct  = null;
		IAct topEnactedAct        = null;
		IAct topRemainingAct      = null;

		// If we are not on startup
		if (intendedPrimitiveAct != null)
		{
			// Compute the enacted primitive act from the intended act and the effect.
			enactedPrimitiveAct = addInteraction(intendedPrimitiveAct.getSchema().getLabel(), enaction.getEffect().getLabel(), 0);

			// Compute the top actually enacted act
			topEnactedAct = enactedAct(intendedPrimitiveAct.getSchema(), enactedPrimitiveAct);
			System.out.println("Enacted " + topEnactedAct );
			
			// Compute the next intention, null if we have reached the end of the intended act.
			topRemainingAct = nextAct(intendedPrimitiveAct, enactedPrimitiveAct);			
		}					
		
		// Update the current enaction
		enaction.setEnactedPrimitiveAct(enactedPrimitiveAct);
		enaction.setTopEnactedAct(topEnactedAct);
		enaction.setTopRemainingAct(topRemainingAct);

		// Trace
		enaction.traceTrack(m_tracer);
	}
	
	/**
	 * Terminate the current enaction.
	 * Use the top intended act, the top enacted Act, the previous learning context, and the initial learning context.
	 * Generates the final activation context and the final learning context.
	 * Record or reinforce the learned acts and schemes. 
	 * @param enaction The current enaction.
	 */
	public void terminate(IEnaction enaction)
	{
		IAct topIntendedAct = enaction.getTopAct();
		IAct topEnactedAct  = enaction.getTopEnactedAct();
		ArrayList<IAct> previousLearningContext = enaction.getPreviousLearningContext();
		ArrayList<IAct> initialLearningContext = enaction.getInitialLearningContext();
		
		// if we are not on startup
		if (topEnactedAct != null)
		{
			// Surprise if the enacted act is not that intended
			if (topIntendedAct != topEnactedAct) 
			{
				m_internalState= "!";
				enaction.setCorrect(false);
			}
			
			// Compute the performed act
			// (the act based on the schema that was originally intended)
			
			IAct performedAct = null;

			ISchema intendedSchema = topIntendedAct.getSchema();
			
			if (intendedSchema == topEnactedAct.getSchema())
				// The intended schema was enacted
				performedAct = topEnactedAct;
			else	
				// The intended schema was not enacted: the performed act is the intended schema with fail status
				//performedAct = m_episodicMemory.addFailingInteraction(intendedSchema,topEnactedAct.getSatisfaction());
				performedAct = addFailingInteraction(intendedSchema,topEnactedAct.getSatisfaction());
			
			//m_tracer.addEventElement("top_performed", performedAct.getLabel() );
			System.out.println("Performed " + performedAct );
			
			// learn from the  context and the performed act
			//m_episodicMemory.resetLearnCount();
			m_nbSchemaLearned = 0;
			//ArrayList<IAct> streamContextList = m_episodicMemory.record(initialLearningContext, performedAct);
			ArrayList<IAct> streamContextList = record(initialLearningContext, performedAct);
						
			// learn from the base context and the stream act			
			 if (streamContextList.size() > 0) // TODO find a better way than relying on the enacted act being on the top of the list
			 {
				 IAct streamAct = streamContextList.get(0); // The stream act is the first learned 
				 System.out.println("Streaming " + streamAct);
				 if (streamAct.getSchema().getWeight() > ACTIVATION_THRESH)
					 //m_episodicMemory.record(previousLearningContext, streamAct);
					 record(previousLearningContext, streamAct);
			 }

			// learn from the current context and the actually enacted act			
			if (topEnactedAct != performedAct)
			{
				System.out.println("Learn from enacted");
				//List<IAct> streamContextList2 = m_episodicMemory.record(initialLearningContext, topEnactedAct);
				List<IAct> streamContextList2 = record(initialLearningContext, topEnactedAct);
				// learn from the base context and the streamAct2
				if (streamContextList2.size() > 0)
				{
					IAct streamAct2 = streamContextList2.get(0);
					System.out.println("Streaming2 " + streamAct2 );
					if (streamAct2.getSchema().getWeight() > ACTIVATION_THRESH)
						//m_episodicMemory.record(previousLearningContext, streamAct2);
						record(previousLearningContext, streamAct2);
				}
			}	
			
			enaction.setFinalContext(topEnactedAct, performedAct, streamContextList);			
		}
		//enaction.setNbActLearned(m_episodicMemory.getLearnCount());
		enaction.setNbActLearned(m_nbSchemaLearned);
		enaction.traceTerminate(m_tracer);

	}

	/**
	 * Add or update a failing possibility of interaction between Ernest and its environment.
	 * Add or update the schema's failing act to Ernest's memory. 
	 * If the failing act does not exist then create it. 
	 * If the failing act exists then update its satisfaction.
	 * @param schema The schema that failed.
	 * @param satisfaction The satisfaction obtained during the failure.
	 * @return The failing act.
	 */
    private IAct addFailingInteraction(ISchema schema, int satisfaction)
    {
    	IAct failingAct = schema.getFailingAct();
    	
		if (!schema.isPrimitive())
		{
			if (failingAct == null)
			{
				failingAct = Act.createCompositeFailingAct(schema, satisfaction);
				schema.setFailingAct(failingAct);
				m_acts.add(failingAct);
			}
			else
				// If the failing act already exists then 
				//  its satisfaction is averaged with the previous value
				failingAct.setSatisfaction((failingAct.getSatisfaction() + satisfaction)/2);
		}
		
		return failingAct;
    }

	/**
	 * Learn from an enacted intention after a given context.
	 * Returns the list of learned acts that are based on reliable subacts. The first act of the list is the stream act.
	 * @param contextList The list of acts that constitute the context in which the learning occurs.
	 * @param intentionAct The intention.
	 * @return A list of the acts created from the learning. The first act of the list is the stream act if the first act of the contextList was the performed act.
	 */
	private ArrayList<IAct> record(List<IAct> contextList, IAct intentionAct)
	{
		ArrayList<IAct> newContextList= new ArrayList<IAct>(20);
		
		if (intentionAct != null)
		{
			// For each act in the context ...
			for (IAct contextAct : contextList)
			{
				// Build a new schema with the context act and the intention act 
				//ISchema newSchema = addCompositeInteraction(contextAct, intentionAct);
				ISchema newSchema = addCompositeSchema(contextAct, intentionAct);
				newSchema.incWeight(m_regularitySensibilityThreshold);
				//System.out.println("learned " + newSchema.getLabel());
				
					// Created acts are part of the context 
					// if their context and intention have passed the regularity
					// if they are based on reliable no�mes
				if ((contextAct.getConfidence() == Imos.RELIABLE) &&
  				   (intentionAct.getConfidence() == Imos.RELIABLE))
				{
					newContextList.add(newSchema.getSucceedingAct());
					// System.out.println("Reliable schema " + newSchema);
				}
			}
		}
		return newContextList; 
	}

	public ArrayList<IAct> getActs()
	{
		return m_acts;
		//return m_episodicMemory.getActs();
	}

	public ArrayList<ISchema> getSchemas()
	{
		return m_schemas;
		//return m_episodicMemory.getSchemas();
	}

	/**
	 * Recursively construct the current actually enacted act. 
	 *  (may construct extra intermediary schemas but that's ok because their weight is not incremented)
	 * @param s The enacted schema.
	 * @param a The intention act.
	 * @return the actually enacted act
	 */
	private IAct enactedAct(ISchema s, IAct a)
	{
		IAct enactedAct = null;
		ISchema prescriberSchema = s.getPrescriberAct().getPrescriberSchema();
		
		if (prescriberSchema == null)
			// top parent schema
			enactedAct = a;
		else
		{
			// The schema was prescribed
			if (prescriberSchema.getPointer() == 0)
			{
				// enacted the prescriber's context 
				enactedAct = enactedAct(prescriberSchema, a);
			}
			else
			{
				// enacted the prescriber's intention
				//ISchema enactedSchema = m_episodicMemory.addCompositeInteraction(prescriberSchema.getContextAct(), a);
				ISchema enactedSchema = addCompositeSchema(prescriberSchema.getContextAct(), a);
				enactedAct = enactedAct(prescriberSchema, enactedSchema.getSucceedingAct());
			}
		}
			
		return enactedAct;
	}
	
	/**
	 * Recursively finds the next act to enact in the hierarchy of prescribers.
	 * @param prescribedAct The prescribed act.
	 * @param enactedAct The enacted act.
	 * @return the next intention act to enact or null if failed or completed
	 */
	private IAct nextAct(IAct prescribedAct, IAct enactedAct)
	{
		IAct nextAct = null;
		ISchema prescriberSchema = prescribedAct.getPrescriberSchema();
		//int activation = prescribedAct.getActivation();
		prescribedAct.setPrescriberSchema(null); 
		//prescribedAct.setActivation(0); // (It might be the case that the same act will be prescribed again)
		
		if (prescriberSchema != null)
		{
			if (prescribedAct == enactedAct)
			{
				//if (m_tracer != null)
				//	m_tracer.addEventElement("intention_correct", prescribedAct.getLabel());
				System.out.println("intention_correct " + prescribedAct.getLabel());
				// Correctly enacted
				if (prescriberSchema.getPointer() == 0)
				{
					// context act correctly enacted, move to intention act
					prescriberSchema.setPointer(1);
					nextAct = prescriberSchema.getIntentionAct();
					nextAct.setPrescriberSchema(prescriberSchema);
					//nextAct.setActivation(activation);
				}
				else
				{
					// intention act correctly enacted, move to prescriber act with a success status
					IAct prescriberAct = prescriberSchema.getPrescriberAct();
					nextAct = nextAct(prescriberAct, prescriberSchema.getSucceedingAct());
				}
			}
			else
			{
				//if (m_tracer != null)
				//	m_tracer.addEventElement("intention_incorrect", prescribedAct.getLabel());
				System.out.println("intention_incorrect " + prescribedAct.getLabel());
				// move to prescriber act with a failure status
				IAct prescriberAct = prescriberSchema.getPrescriberAct();
				nextAct = nextAct(prescriberAct, prescriberSchema.getFailingAct());				
			}
		}
		
		//if (nextAct !=null && m_tracer != null)
		//	m_tracer.addEventElement("composite_intention", nextAct.getLabel());

		return nextAct;
	}
	
	public int getCounter() 
	{
		return m_imosCycle;
	}

//    public IAct addCompositeInteraction(IAct contextAct, IAct intentionAct)
//    {
//    	
//    	//IAct act =  m_episodicMemory.addCompositeInteraction(contextAct, intentionAct).getSucceedingAct();
//    	IAct act =  addCompositeSchema(contextAct, intentionAct).getSucceedingAct();
//    	
//    	act.setConfidence(Imos.HYPOTHETICAL);
//    	return act;
//    }
    
	/**
	 * Add a composite schema and its succeeding act that represent a composite possibility 
	 * of interaction between Ernest and its environment. 
	 * @param contextAct The context Act.
	 * @param intentionAct The intention Act.
	 * @return The schema made of the two specified acts, whether it has been created or it already existed. 
	 */
    private ISchema addCompositeSchema(IAct contextAct, IAct intentionAct)
    {
    	ISchema s = Schema.createCompositeSchema(m_schemas.size() + 1, contextAct, intentionAct);
    	
		int i = m_schemas.indexOf(s);
		if (i == -1)
		{
			// The schema does not exist: create its succeeding act and add it to Ernest's memory
			IAct a = Act.createCompositeSucceedingAct(s); 
	    	s.setSucceedingAct(a);
			m_schemas.add(s);
			m_acts.add(a);
			//m_learnCount++;
			m_nbSchemaLearned++;
		}
		else
			// The schema already exists: return a pointer to it.
			s =  m_schemas.get(i);
    	return s;
    }

}
