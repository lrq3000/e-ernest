package ernest;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.vecmath.Vector3f;

import imos.IAct;

import org.w3c.dom.Element;

import spas.IObservation;
import spas.IPlace;
//import spas.IStimulation;
import spas.IBundle;
import spas.ISegment;
import spas.LocalSpaceMemory;
import spas.Observation;
import spas.Place;
import spas.Spas;
//import spas.Stimulation;
import utils.ErnestUtils;

/**
 * Implement Ernest 11.0's sensorimotor system.
 * @author ogeorgeon
 */
public class SpatialSensorimotorSystem  extends BinarySensorymotorSystem
{
	/** The impulsion for translation */
	public final static float TRANSLATION_IMPULSION = .15f;//.10f; // .10f; // .15f
	/** The impulsion for rotation */
	final static float ROTATION_IMPULSION = 0.123f;// .123f;//(float)Math.toRadians(7f); // degrees   . 5.5f
	/** The minimum speed before starting a new interaction */
	public final static float MINIMUM_SPEED = 0.05f;// .05f
	
	/** The maximum angle before starting a new interaction */
	public final static float MAXIMUM_ANGLE = (float)Math.PI/8;
	/** The delay when to measure the acceleration produced by the impulsion */
	public final static int IMPULSE_DELAY = 1;
	/** The delay when to consider an interaction succesfully enacted */
	public final static int INTERACTION_ONGOING = 3;
	
	/** The observation generated by the spatial system */
	private IObservation m_observation = null;
	
	/** The primitive act being enacted */
	//private IAct m_primitiveAct = null;
	
	private int m_interactionTimer = 0;
	private IObservation m_initialObservation = new Observation();
	private String m_expectedInstantaneousFeedback = "";
	
	/** The place of the last interaction */
	IPlace m_interactionPlace = null;

	/** Temporary places.  */
	ArrayList<IPlace> m_places = new ArrayList<IPlace>();
	
	/** Segments directly perceived.  */
	ArrayList<ISegment> m_segmentList = new ArrayList<ISegment>();
	
	public int[] update(int[][] stimuli) 
	{
		IObservation newObservation  = new Observation();
		
		//IAct primitiveAct = null;
		if (m_observation != null)
			newObservation.setPrimitiveAct(m_observation.getPrimitiveAct());
			//primitiveAct = m_observation.getPrimitiveAct();

		m_interactionTimer++;
		
		int primitiveSchema[] = new int[2];
		newObservation.setGustatoryValue(stimuli[0][8]); 
		newObservation.setKinematicValue(stimuli[1][8]);
		float translationx = (float) stimuli[2][8] / Ernest.INT_FACTOR; 
		float translationy = (float) stimuli[3][8] / Ernest.INT_FACTOR;
		float rotation = (float) stimuli[4][8] / Ernest.INT_FACTOR;
		//float speed = (float) stimuli[5][8] / Ernest.INT_FACTOR;
		int cognitiveMode = stimuli[6][8];
		
		newObservation.setTranslation(new Vector3f(translationx, translationy, 0));
		newObservation.setRotation(rotation);

		// Touch =====
		
		for (int i = 0; i < 9; i++)
			newObservation.setTactileStimuli(i, stimuli[i][9]);

    	// The Visual observation.
		
		for (int i = 0; i < Ernest.RESOLUTION_RETINA; i++)
		{
			newObservation.setVisualStimuli(i,stimuli[i][1] * 65536 + stimuli[i][2] * 256 + stimuli[i][3]);
			//float angle = (float) (- 11 * Math.PI/24 + i * Math.PI/12); 
			//Vector3f pos = new Vector3f((float) Math.cos(angle) * stimuli[i][0] / Ernest.INT_FACTOR, (float) Math.sin(angle) * stimuli[i][0] / Ernest.INT_FACTOR, 0);
			//m_visualStimulations[i].setPosition(pos);
		}
    	//sense(stimuli);
    	
		// The spatial observation ==========================================
		
		m_places.clear();	
		m_spas.tick();
		addSegmentPlaces(m_segmentList);
		addTactilePlaces(newObservation.getTactileStimuli());
		m_spas.step(newObservation, m_places);
		synergy(m_interactionPlace, newObservation);
		
		// A spatial affordance was triggered
		boolean affordance = false;
		//if (newObservation.getAffordanceAct() != null)
		//	affordance = true;
		
    	// The dynamic observation ==========================================
		
		boolean endInteraction = false;
		if (m_observation != null )
			endInteraction = dynamicFeedback(m_observation, newObservation);

    	// Memorize the initial observation.

		if (m_interactionTimer == IMPULSE_DELAY) // The acceleration is observed with a delay.
    		m_initialObservation = newObservation;
    		
		//m_observation = newObservation;

    	primitiveSchema[0] = 0;
    	primitiveSchema[1] = 0;
    	
    	// Trigger a new cognitive loop when the previous interaction has ended =============
    	
    	if (endInteraction && cognitiveMode > 0)
        {
        	//m_spas.count(); // Tick the clock of persistence memory
    		IAct newPrimitiveAct = null;

        	
    		m_interactionTimer = 0;
    		        	
    		IAct enactedPrimitiveAct = null;
 
    		if (m_tracer != null)
    		{
                m_tracer.startNewEvent(m_imos.getCounter());
    			m_tracer.addEventElement("clock", m_imos.getCounter() + "");
    		}                

    		// If the intended act was null (during the first cycle), then the enacted act is null.

    		// Compute the enacted act == 
    		
    		if (newObservation.getPrimitiveAct() != null)
    		{
    			enactedPrimitiveAct = m_imos.addInteraction(newObservation.getPrimitiveAct().getSchema().getLabel(), newObservation.getStimuli(), newObservation.getSatisfaction());

    			if (m_tracer != null) 
    				m_tracer.addEventElement("primitive_enacted_schema", newObservation.getPrimitiveAct().getSchema().getLabel());
    		}
    		
    		// Let Ernest decide for the next primitive schema to enact =========================
    		
    		if (affordance)
    			primitiveSchema[0] = newObservation.getAffordanceAct().getSchema().getLabel().toCharArray()[0];
    		else
    		{    		
	    		newPrimitiveAct = m_imos.step(enactedPrimitiveAct);
	    		newObservation.setPrimitiveAct(newPrimitiveAct);
    		}   		
    		primitiveSchema[0] = newPrimitiveAct.getSchema().getLabel().toCharArray()[0];
    		
    		// Expected instantaneous feedback ==================================================
    		
    		if (newPrimitiveAct.getLabel().indexOf("-") >= 0)
    			m_expectedInstantaneousFeedback = "-";
    		else if (newPrimitiveAct.getLabel().indexOf("+") >= 0)
    			m_expectedInstantaneousFeedback = "+";
    		else if (newPrimitiveAct.getLabel().indexOf("_") >= 0)
    			m_expectedInstantaneousFeedback = "_";
    		else if (newPrimitiveAct.getLabel().indexOf("*") >= 0)
    			m_expectedInstantaneousFeedback = "*";
    		else
    			m_expectedInstantaneousFeedback = "";
    		
    		// Once the decision is made, compute the intensity.
    		
    		primitiveSchema[1] = impulsion(primitiveSchema[0]);
    		
    		// Trace the interaction

			int shape = Spas.SHAPE_TRIANGLE;
    		if (primitiveSchema[0] != '>')
    			shape = Spas.SHAPE_PIE;
    		float or = 0;
    		if (primitiveSchema[0] == '^')
    			or = (float)Math.PI;
    		if (m_imos.newIntention())
    		{
    			if (m_imos.compositeIntention())
    				m_interactionPlace = m_spas.addPlace(new Vector3f(), Spas.PLACE_COMPOSITE, shape); // Mark the place where the agent is standing.
    			else
    				m_interactionPlace = m_spas.addPlace(new Vector3f(), Spas.PLACE_PRIMITIVE, shape); // Mark the place where the agent is standing.
    			//m_spas.addPlace(m_observation.getPosition(), Spas.PLACE_FOCUS, Spas.SHAPE_CIRCLE); // Mark the place of focus.
    		}
    		else
    			m_interactionPlace = m_spas.addPlace(new Vector3f(), Spas.PLACE_INTERMEDIARY, shape); // Mark the place where the agent is standing.    		
    		m_interactionPlace.setOrientation(or);

    		// Trace
    		if (m_tracer != null)
    		{
    			newObservation.trace(m_tracer);
    			m_spas.traceLocalSpace();
    		}
        }
    	
		m_observation = newObservation;

		return primitiveSchema;    		
	}
	
	/**
	 * Generate the instantaneous feedback that is computed from the instantaneous relative acceleration of the focus.
	 * @param previousObservation The observation made on the previous cycle.
	 * @param newObservation The current observation .
	 */
	private boolean dynamicFeedback(IObservation previousObservation, IObservation newObservation)
	{
		String instantaneousFeedback = "";
		IAct primitiveAct = previousObservation.getPrimitiveAct();
		
		// Compute the speed of tactile places TODO change this
		if (newObservation.getSpeed().z == .01f)
		{
			Vector3f relativeSpeed = new Vector3f(newObservation.getPosition());
			relativeSpeed.sub(previousObservation.getPosition());
			
			Vector3f rotationSpeed = new Vector3f(- newObservation.getPosition().y, newObservation.getPosition().x, 0); // Orthogonal to the position vector.
			rotationSpeed.normalize();
			rotationSpeed.scale(- newObservation.getRotation());
			relativeSpeed.add(rotationSpeed);
			newObservation.setSpeed(relativeSpeed);
		}
		
		Vector3f relativeAcceleration = new Vector3f(newObservation.getSpeed());
		relativeAcceleration.sub(previousObservation.getSpeed());
		
		if (newObservation.getAttractiveness() >= 0)
		{
			// Positive attractiveness
			// Move forward
			if (primitiveAct != null && primitiveAct.getSchema().getLabel().equals(">"))
			{
				if (relativeAcceleration.dot(newObservation.getPosition()) < 0 &&
					Math.abs(newObservation.getDirection()) < Math.PI/4)
					// Closer
					instantaneousFeedback = "+";
				else
					// Farther
					instantaneousFeedback = "-";
			}
			else
			{
				if (relativeAcceleration.x > 0)
					// More frontwards
					instantaneousFeedback = "+";
				else
					// More backward
					instantaneousFeedback = "-";
			}
		}
		else
		{
			// Negative attractiveness (repulsion)
			
			if (previousObservation.getAttractiveness() >= 0)
				// A wall appeared with a part of it in front of Ernest
				instantaneousFeedback = "*";		
			else 
			{
				// already in front of a wall.
				if (primitiveAct != null && primitiveAct.getSchema().getLabel().equals(">"))
				{
					if (relativeAcceleration.dot(newObservation.getPosition()) <= 0)
						// Closer
						instantaneousFeedback = "*";
					else
						// Farther
						instantaneousFeedback = "_";
				}
				else
				{
					if (relativeAcceleration.x > 0)
						// More to front
						instantaneousFeedback = "*";
					else
						// More to the side
						instantaneousFeedback = "_";
				}
			}
		}	
		
		newObservation.setInstantaneousFeedback(instantaneousFeedback);

//	 * Generate the dynamic stimuli from the impact in the local space memory.
//	 * The stimuli come from: 
//	 * - The kinematic feature.
//	 * - The variation in attractiveness and in direction of the object of interest. 

		boolean endInteraction = false;
		
		int   newAttractiveness = newObservation.getAttractiveness();
		float newDirection = newObservation.getDirection();
		
		String finalFeedback = "";
		
		float minFovea =  - (float)Math.PI / 4 + 0.01f;
		float maxFovea =    (float)Math.PI / 4 - 0.01f;
		
		// Incorrect ending
		// If the initial instantaneous feedback is not that expected then the interaction is ended.
		if (m_interactionTimer >= INTERACTION_ONGOING && !m_expectedInstantaneousFeedback.equals(m_initialObservation.getInstantaneousFeedback()))
			endInteraction = true;
		
		// Correct ending
		// If the current instantaneous feedback is no longer correct
		if (m_interactionTimer > INTERACTION_ONGOING )
		{
			if (primitiveAct != null && primitiveAct.getSchema().getLabel().equals(">"))
			// Move forward correct ending conditions
			{
				//if (newObservation.getPosition().dot(newObservation.getSpeed()) > 0 || Math.abs(newObservation.getDirection()) > Math.PI/4)
				if (newObservation.getSpeed().x < 0 || Math.abs(newObservation.getDirection()) > MAXIMUM_ANGLE)
					// getting away
					endInteraction = true;
				//else if (newObservation.getSpeed().length() < MINIMUM_SPEED)
				//else if (- newObservation.getPosition().dot(newObservation.getSpeed())/newObservation.getSpeed().length() < MINIMUM_SPEED)
				else if (- newObservation.getSpeed().x < MINIMUM_SPEED)
					// stopped
					endInteraction = true;
			}
			else
			// Turn correct ending conditions
			{
				if (newObservation.getSpeed().x < 0 || Math.abs(newObservation.getDirection()) > MAXIMUM_ANGLE)
					endInteraction = true;
				//else if (newObservation.getSpeed().length() < MINIMUM_SPEED)
				//else if (- newObservation.getPosition().dot(newObservation.getSpeed())/newObservation.getSpeed().length() < MINIMUM_SPEED)
				else if (- newObservation.getSpeed().x < MINIMUM_SPEED)
					// stopped
					endInteraction = true;
			}
		}
			
		
		// The final feedback is constructed from the initial instantaneous feedback and the ending condition.
		
		int satisfaction = 0;

		finalFeedback = m_initialObservation.getInstantaneousFeedback();

		if (newAttractiveness >= 0)
		{
			// Positive attractiveness
			{
				// Satisfaction
				if (finalFeedback.equals("-"))
					satisfaction = -100;
				if (finalFeedback.equals("+"))
					satisfaction = 20;

				// Direction
				if (!finalFeedback.equals(""))
				{
					if (newDirection <= minFovea)
						finalFeedback = "|" + finalFeedback;
					else if (newDirection >= maxFovea )
						finalFeedback = finalFeedback + "|";
				}		
			}
		}
		else
		{
			// Negative attractiveness (repulsion)
			// Satisfaction
			if (finalFeedback.equals("*"))
				satisfaction = -100;
			if (finalFeedback.equals("_"))
				satisfaction = 20;
			
			// Direction
			if (!finalFeedback.equals(""))
			{
				if (newDirection < -0.1f ) 
					finalFeedback = "|" + finalFeedback;
				else if (newDirection > 0.1f )
					finalFeedback = finalFeedback + "|";
			}		
		}
		
		// Gustatory
		
		if (newObservation.getGustatoryValue() != Ernest.STIMULATION_GUSTATORY_NOTHING)
		{
			finalFeedback = "e";
			satisfaction = 100;
		}
		
		// Kinematic
		
		boolean status = (newObservation.getKinematicValue() != Ernest.STIMULATION_KINEMATIC_BUMP);
		
		newObservation.setStimuli((status ? " " : "w") + finalFeedback);

		if (primitiveAct != null && primitiveAct.getSchema().getLabel().equals(">"))
			satisfaction = satisfaction + (status ? 20 : -100);
		else
			satisfaction = satisfaction + (status ? -10 : -20);
		
		newObservation.setSatisfaction(satisfaction);

		newObservation.setVisualFeedback(finalFeedback);
		
		return endInteraction;
	}
	
	public int impulsion(int intentionSchema) 
	{
		int impulsion = 0;
		
		if (intentionSchema == '>')
		{
			impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR);
//			if (m_observation.getDistance() < .5f)
//				impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR * .5f);
//			if (m_observation.getDistance() < 1.1f)
//				impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR * m_observation.getDistance());
//			else
//				impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR * 1.1f);
		}
		if (intentionSchema == '^' || intentionSchema == 'v' )
		{ 
			impulsion = (int)(ROTATION_IMPULSION * Ernest.INT_FACTOR);
//			if (Math.abs(m_observation.getDirection()) > Math.PI/8)
//				impulsion = (int)(ROTATION_IMPULSION * Ernest.INT_FACTOR * Math.abs(m_observation.getDirection()) / (Math.PI/4));
//			if (impulsion > 2 * ROTATION_IMPULSION * Ernest.INT_FACTOR)
//				impulsion = (int)(2 * ROTATION_IMPULSION * Ernest.INT_FACTOR);
			
			//return (int)(Math.abs(m_observation.getPlace().getDirection()) * 1000);
		}
		return impulsion;
	}
	
	public void setSegmentList(ArrayList<ISegment> segmentList) 
	{
		m_segmentList = segmentList;
	}
	
	/**
	 * Add places from segments provided by Vacuum_SG.
	 * Create or recognize the associated bundle.
	 * @param segmentList The list of segments.
	 */
	private void addSegmentPlaces(ArrayList<ISegment> segmentList)
	{
		for (ISegment segment : segmentList)
		{
			IBundle b = m_spas.seeBundle(segment.getValue());
			if (b == null)
				//b = m_persistenceMemory.addBundle(segment.getValue(), Ernest.STIMULATION_TOUCH_EMPTY, Ernest.STIMULATION_KINEMATIC_FORWARD, Ernest.STIMULATION_GUSTATORY_NOTHING);
				b = m_spas.addBundle(segment.getValue(), Ernest.STIMULATION_TOUCH_EMPTY);
			IPlace place = new Place(b,segment.getPosition());
			place.setSpeed(segment.getSpeed());
			place.setSpan(segment.getSpan());
			//place.setFirstPosition(segment.getFirstPosition()); // First and second are in the trigonometric direction (counterclockwise). 
			//place.setSecondPosition(segment.getSecondPosition());
			place.setFirstPosition(segment.getSecondPosition()); 
			place.setSecondPosition(segment.getFirstPosition());
			if (segment.getRelativeOrientation() == Ernest.INFINITE)
			{
				Vector3f relativeOrientation = new Vector3f(segment.getFirstPosition());
				relativeOrientation.sub(segment.getSecondPosition());
				place.setOrientation(ErnestUtils.polarAngle(relativeOrientation));
			}
			else				
				place.setOrientation(segment.getRelativeOrientation());
			place.setUpdateCount(m_spas.getClock());
			// Long segments are processed only for display (background).
			if (segment.getWidth() < 1.1f)
				place.setType(Spas.PLACE_SEE);
			else 
				place.setType(Spas.PLACE_BACKGROUND);
			m_places.add(place);			
		}
	}

	/**
	 * Add places in the peripersonal space associated with tactile bundles.
	 * TODO Handle a tactile place behind the agent (last place connected to first place).
	 * @param tactileStimulations The list of tactile stimulations.
	 */
	private void addTactilePlaces(int[] tactileStimulations)
	{

		int tactileStimulation = tactileStimulations[0];
		int span = 1;
		float theta = - 3 * (float)Math.PI / 4; 
		float sumDirection = theta;
		float spanf = (float)Math.PI / 4;
		
		for (int i = 1 ; i <= 7; i++)
		{
			theta += (float)Math.PI / 4;
			if ((i < 7) && tactileStimulations[i] == tactileStimulation)
			{
				// measure the salience span and average direction
				span++;
                sumDirection += theta;
                spanf += (float)Math.PI / 4;
			}
			else 
			{	
				if (tactileStimulation != Ernest.STIMULATION_TOUCH_EMPTY)
				{
					// Create a tactile bundle.
					float direction = sumDirection / span;
					Vector3f position = new Vector3f((float)(Ernest.TACTILE_RADIUS * Math.cos((double)direction)), (float)(Ernest.TACTILE_RADIUS * Math.sin((double)direction)), 0f);
					float firstDirection = direction - spanf/ 2;
					Vector3f firstPosition = new Vector3f((float)(Ernest.TACTILE_RADIUS * Math.cos((double)firstDirection)), (float)(Ernest.TACTILE_RADIUS * Math.sin((double)firstDirection)), 0f);
					float secondDirection = direction + spanf/ 2;
					Vector3f secondPosition = new Vector3f((float)(Ernest.TACTILE_RADIUS * Math.cos((double)secondDirection)), (float)(Ernest.TACTILE_RADIUS * Math.sin((double)secondDirection)), 0f);
					
					// See in that direction ====
					IPlace place = seePlace(direction);
					
					if (place == null)
					{
						// Nothing seen: create a tactile bundle and place it here.
						//IBundle b = m_persistenceMemory.addBundle(Ernest.STIMULATION_VISUAL_UNSEEN, tactileStimulation, Ernest.STIMULATION_KINEMATIC_FORWARD, Ernest.STIMULATION_GUSTATORY_NOTHING);
						IBundle b = m_spas.addBundle(Ernest.STIMULATION_VISUAL_UNSEEN, tactileStimulation);
						place = addOrReplacePlace(b, position);
						place.setFirstPosition(firstPosition);
						place.setSecondPosition(secondPosition);
						place.setSpan(spanf);
						place.setSpeed(new Vector3f(0,0,.01f)); // (Keeping the speed "null" generates errors in the Local Space Memory display).
						place.setUpdateCount(m_spas.getClock());
						place.setType(Spas.PLACE_TOUCH);
					}
					else
					{
						if (place.getBundle().getTactileValue() == tactileStimulation )//&&
							//place.getFrontDistance() < Ernest.TACTILE_RADIUS + .1f) // vision now provides distance
						{
							// A bundle is seen with the same tactile value: This is it!
							place.getBundle().setLastTimeBundled(m_spas.getClock());//m_persistenceMemory.getClock());
							// move the visual place to the tactile radius.
							place.setPosition(position); // Position is more precise with tactile perception, especially for long walls.
							place.setFirstPosition(firstPosition);
							place.setSecondPosition(secondPosition);
							place.setSpan(spanf);
							place.setType(Spas.PLACE_TOUCH);
							//place.setUpdateCount(m_persistenceMemory.getUpdateCount());
						}
						else if (place.getBundle().getTactileValue() == Ernest.STIMULATION_TOUCH_EMPTY )//&& 
								//place.getFrontDistance() < Ernest.TACTILE_RADIUS + .1f)
						{
							// A bundle is seen in the same position with no tactile value.
							
							// Update the place and the bundle
							//IBundle b = m_persistenceMemory.addBundle(place.getBundle().getVisualValue(), tactileStimulation, Ernest.STIMULATION_KINEMATIC_FORWARD, Ernest.STIMULATION_GUSTATORY_NOTHING);
							IBundle b = m_spas.addBundle(place.getBundle().getVisualValue(), tactileStimulation);
							place.setBundle(b);
							
							//place.getBundle().setTactileValue(tactileStimulation.getValue());
							//place.getBundle().setLastTimeBundled(m_persistenceMemory.getClock());
							place.setPosition(position);							
							place.setFirstPosition(firstPosition);
							place.setSecondPosition(secondPosition);
							place.setSpan(spanf);
							place.setType(Spas.PLACE_TOUCH);
							//place.setUpdateCount(m_persistenceMemory.getUpdateCount());
						}
					}
				}
				// look for the next bundle
				if (i < 7)
				{
					tactileStimulation = tactileStimulations[i];
					span = 1;
					spanf = (float)Math.PI / 4;
					sumDirection = theta;
				}
			}
		}
	}

	/**
	 * Associate affordances to the bundle ahead.
	 * @param interactionPlace The place where the ongoing interaction started.
	 * @param observation The current observation.
	 */
	private void synergy(IPlace interactionPlace, IObservation observation)
	{
		int synergyValue= observation.getGustatoryValue();
		//if (observation.getKinematicValue() == Ernest.STIMULATION_KINEMATIC_BUMP)
		//	synergyValue = observation.getKinematicValue();
		if (synergyValue == Ernest.STIMULATION_GUSTATORY_NOTHING)
			synergyValue = observation.getKinematicValue();
		
		//if (synergyValue != Ernest.STIMULATION_GUSTATORY_NOTHING)
		//{
			//IPlace focusPlace = observation.getFocusPlace();
			IPlace focusPlace = getPlace(LocalSpaceMemory.DIRECTION_AHEAD);
			IBundle focusBundle = null;
			if (focusPlace != null) focusBundle = focusPlace.getBundle();
	
			if (focusBundle != null)
			{
				// Add the affordance to the bundle
				Vector3f relativePosition = new Vector3f(interactionPlace.getPosition());
				relativePosition.sub(new Vector3f(.4f, 0,0));
				ErnestUtils.rotate(relativePosition, - focusPlace.getOrientation());
				int attractiveness = Ernest.ATTRACTIVENESS_OF_UNKNOWN;
				if (synergyValue == Ernest.STIMULATION_GUSTATORY_FISH) attractiveness = Ernest.ATTRACTIVENESS_OF_FISH;
				if (synergyValue == Ernest.STIMULATION_GUSTATORY_CUDDLE) attractiveness = Ernest.ATTRACTIVENESS_OF_CUDDLE;
				if (synergyValue == Ernest.STIMULATION_KINEMATIC_BUMP) attractiveness = Ernest.ATTRACTIVENESS_OF_BUMP;
				focusBundle.addAffordance(observation.getPrimitiveAct(), interactionPlace, relativePosition, focusPlace.getOrientation(), attractiveness, synergyValue);
			}
			
			if (synergyValue != Ernest.STIMULATION_GUSTATORY_NOTHING)
			{
				// Mark the synergy place.
				Vector3f pos = new Vector3f(LocalSpaceMemory.DIRECTION_AHEAD);
				pos.scale(Ernest.BOUNDING_RADIUS);
				IPlace k = m_spas.addPlace(focusBundle, pos);
				k.setFirstPosition(pos);
				k.setSecondPosition(pos);
				k.setType(Spas.PLACE_BUMP);
				k.setUpdateCount(m_spas.getClock());
			}
	}
	/**
	 * Find the closest place whose span overlaps this direction.
	 * @param direction The direction in which to look at.
	 * @return The place.
	 */
	public IPlace seePlace(float direction)
	{
		IPlace place = null;

		for (IPlace p : m_places)
		{
			float firstAngle = ErnestUtils.polarAngle(p.getFirstPosition());
			float secondAngle = ErnestUtils.polarAngle(p.getSecondPosition());
			if (firstAngle < secondAngle)
			{
				// Does not overlap direction -PI
				if (direction > firstAngle + 0.1f && direction < secondAngle - .05f && 
					p.getBundle().getVisualValue() != Ernest.STIMULATION_VISUAL_UNSEEN &&
					p.attractFocus(m_spas.getClock()))
						if (place == null || p.getDistance() < place.getDistance())
							place = p;
			}
			else
			{
				// Overlaps direction -PI
				if (direction > firstAngle + .1f || direction < secondAngle - .1f &&
					p.getBundle().getVisualValue() != Ernest.STIMULATION_VISUAL_UNSEEN &&
					p.attractFocus(m_spas.getClock()))
						if (place == null || p.getDistance() < place.getDistance())
							place = p;				
			}
		}
		return place;
	}
	
	private IPlace addOrReplacePlace(IBundle bundle, Vector3f position)
	{
		// The initial position must be cloned so that 
		// the position can be moved without changing the position used for intialization.
		Vector3f pos = new Vector3f(position);
		
		IPlace p = new Place(bundle, pos);
		p.setUpdateCount(m_spas.getClock());
		
		int i = m_places.indexOf(p);
		if (i == -1)
			// The place does not exist
			m_places.add(p);
		else 
		{
			// The place already exists: return a pointer to it.
			p =  m_places.get(i);
			p.setBundle(bundle);
		}
		return p;
	}

	/**
	 * Get the first place found at a given position.
	 * @param position The position of the location.
	 * @return The place.
	 */
	private IPlace getPlace(Vector3f position)
	{
		IPlace place = null;
		for (IPlace p : m_places)
		{
			if (p.attractFocus(m_spas.getClock()))
			{
				//if (p.isInCell(position) && p.attractFocus(m_persistenceMemory.getUpdateCount()))
				Vector3f compare = new Vector3f(p.getPosition());
				compare.sub(position);
				if (compare.length() < 1f)
					place = p;
			}
		}
		return place;
	}

	/**
	 * Clear a location in the local space memory.
	 * @param position The position to clear.
	 */
	public void clearPlace(Vector3f position)
	{
		for (Iterator it = m_places.iterator(); it.hasNext();)
		{
			IPlace l = (IPlace)it.next();
			if (l.isInCell(position))
				it.remove();
		}		
	}


}