package ernest;

import javax.vecmath.Vector3f;

import imos.IAct;

import org.w3c.dom.Element;

import spas.IObservation;
import spas.IPlace;
import spas.IStimulation;
import spas.LocalSpaceMemory;
import spas.Observation;
import spas.Spas;
import spas.Stimulation;
import utils.ErnestUtils;

/**
 * Implement Ernest 11.0's sensorimotor system.
 * @author ogeorgeon
 */
public class SpatialSensorimotorSystem  extends BinarySensorymotorSystem
{
	/** The current observation generated by the spatial system */
	private IObservation m_observation = null;
	
	private String m_visualStimuli = "";
	private String m_stimuli = "";
	private int m_satisfaction = 0;
	private boolean m_status;
	private IAct m_primitiveAct = null;
	private float m_rotation = 0;
	
	private IStimulation[] m_visualStimulations;
	private IStimulation[] m_tactileStimulations;
	private IStimulation m_kinematicStimulation;
	private IStimulation m_gustatoryStimulation;

	public final static float TRANSLATION_IMPULSION = .10f; // .10f; // .15f
	final static float ROTATION_IMPULSION = 0.123f;// .123f;//(float)Math.toRadians(7f); // degrees   . 5.5f
	public final static float MINIMUM_SPEED = 0.02f;// .05f
	public final static int IMPULSE_DELAY = 1;
	public final static int INTERACTION_ONGOING = 3;
	
	private int m_interactionTimer = 0;
	private IObservation m_initialObservation = new Observation();
	private String m_expectedInstantaneousFeedback = "";

	public int[] update(int[][] stimuli) 
	{
		m_interactionTimer++;
		m_spas.tick();
		
		int primitiveSchema[] = new int[2];
		float translationx = (float) stimuli[2][8] / Ernest.INT_FACTOR; 
		float translationy = (float) stimuli[3][8] / Ernest.INT_FACTOR;
		m_rotation = (float) stimuli[4][8] / Ernest.INT_FACTOR;
		float speed = (float) stimuli[5][8] / Ernest.INT_FACTOR;
		int cognitiveMode = stimuli[6][8];

		// Update the local space memory
    	m_spas.update(new Vector3f(-translationx, -translationy, 0), - m_rotation);

    	// Sense the environment
    	sense(stimuli);
    	
		// Generate a spatial observation ====
		
		//IObservation newObservation = m_spas.step(m_visualStimulations, m_tactileStimulations, m_kinematicStimulation, m_gustatoryStimulation);		
		IObservation newObservation = m_spas.step(m_tactileStimulations, m_kinematicStimulation, m_gustatoryStimulation);
		
    	// Update the feedback.
		boolean endInteraction = false;
		if (m_observation != null )//&& m_primitiveAct != null)
		{
			setInstantaneousFeedback(m_observation, newObservation);
			endInteraction = setFinalFeedback(m_observation, newObservation);
		}
		else
		{
			newObservation.setSpeed(new Vector3f());
			//endInteraction= true;
		}

    	// Record the initial observation.
    	if (m_interactionTimer == IMPULSE_DELAY) // The acceleration is observed with a delay.
    	{
    		m_initialObservation = newObservation;
    	}
    		
		m_observation = newObservation;

    	primitiveSchema[0] = 0;
    	primitiveSchema[1] = 0;
    	
    	// Trigger a new cognitive loop when the previous interaction has ended.
    	
    	if (endInteraction && cognitiveMode > 0)
        {
        	m_spas.count(); // Tick the clock of persistence memory

    		m_interactionTimer = 0;
    		        	
    		IAct enactedPrimitiveAct = null;
 
    		if (m_tracer != null)
    		{
                m_tracer.startNewEvent(m_imos.getCounter());
    			m_tracer.addEventElement("clock", m_imos.getCounter() + "");
    		}                

    		// If the intended act was null (during the first cycle), then the enacted act is null.

    		// Compute the enacted act == 
    		
    		if (m_primitiveAct != null)
    		{
    			enactedPrimitiveAct = m_imos.addInteraction(m_primitiveAct.getSchema().getLabel(), m_stimuli, m_satisfaction);

    			if (m_tracer != null) 
    				m_tracer.addEventElement("primitive_enacted_schema", m_primitiveAct.getSchema().getLabel());
    		}
    		
    		// Let Ernest decide for the next primitive schema to enact.
    		
    		m_primitiveAct = m_imos.step(enactedPrimitiveAct);
    		primitiveSchema[0] = m_primitiveAct.getSchema().getLabel().toCharArray()[0];
    		
    		// Expected instantaneous feedback
    		
    		if (m_primitiveAct.getSchema().getLabel().indexOf("-") >= 0)
    			m_expectedInstantaneousFeedback = "-";
    		if (m_primitiveAct.getSchema().getLabel().indexOf("+") >= 0)
    			m_expectedInstantaneousFeedback = "+";
    		if (m_primitiveAct.getSchema().getLabel().indexOf("_") >= 0)
    			m_expectedInstantaneousFeedback = "_";
    		if (m_primitiveAct.getSchema().getLabel().indexOf("*") >= 0)
    			m_expectedInstantaneousFeedback = "*";
    		else
    			m_expectedInstantaneousFeedback = "";
    		
    		// Once the decision is made, compute the intensity.
    		
    		primitiveSchema[1] = impulsion(primitiveSchema[0]);

			int shape = Spas.SHAPE_TRIANGLE;
    		if (primitiveSchema[0] != '>')
    			shape = Spas.SHAPE_PIE;
    		float or = 0;
    		if (primitiveSchema[0] == '^')
    			or = (float)Math.PI;
    		IPlace agentPlace = null;
    		if (m_imos.newIntention())
    		{
    			if (m_imos.compositeIntention())
    				agentPlace = m_spas.addPlace(new Vector3f(), Spas.PLACE_COMPOSITE, shape); // Mark the place where the agent is standing.
    			else
    				agentPlace = m_spas.addPlace(new Vector3f(), Spas.PLACE_PRIMITIVE, shape); // Mark the place where the agent is standing.
    			m_spas.addPlace(m_observation.getPosition(), Spas.PLACE_FOCUS, Spas.SHAPE_CIRCLE); // Mark the place of focus.
    		}
    		else
    			agentPlace = m_spas.addPlace(new Vector3f(), Spas.PLACE_INTERMEDIARY, shape); // Mark the place where the agent is standing.    		
    		agentPlace.setOrientation(or);
    		
    		if (m_tracer != null)
    		{
    			// Observation
    			Object e = m_tracer.addEventElement("current_observation");
    			m_tracer.addSubelement(e, "direction", m_observation.getDirection() + "");
    			m_tracer.addSubelement(e, "distance", m_observation.getDistance() + "");
    			m_tracer.addSubelement(e, "span", m_observation.getSpan() + "");
    			m_tracer.addSubelement(e, "attractiveness", m_observation.getAttractiveness() + "");
    			m_tracer.addSubelement(e, "relative_speed_x", m_observation.getSpeed().x + "");
    			m_tracer.addSubelement(e, "relative_speed_y", m_observation.getSpeed().y + "");
    			m_tracer.addSubelement(e, "stimuli", m_stimuli);
    			m_tracer.addSubelement(e, "dynamic_feature", m_visualStimuli);
    			m_tracer.addSubelement(e, "satisfaction", m_satisfaction + "");
    			m_tracer.addSubelement(e, "kinematic", m_observation.getKinematicStimulation().getHexColor());
    			m_tracer.addSubelement(e, "gustatory", m_observation.getGustatoryStimulation().getHexColor());
    			m_tracer.addSubelement(e, "type", m_observation.getType() + "");
    			m_tracer.addSubelement(e, "update_count", m_observation.getUpdateCount() + "");
    			if (m_observation.getNewFocus()) m_tracer.addSubelement(e, "new_focus");
    			
    			Object focusElmt = m_tracer.addEventElement("focus");
    			m_tracer.addSubelement(focusElmt, "salience", ErnestUtils.hexColor(m_observation.getBundle().getValue()));
    			m_observation.getBundle().trace(m_tracer, "focus_bundle");

    			// Vision
				Object retinaElmt = m_tracer.addEventElement("retina");
				for (int i = Ernest.RESOLUTION_RETINA - 1; i >= 0 ; i--)
					m_tracer.addSubelement(retinaElmt, "pixel_0_" + i, m_visualStimulations[i].getHexColor());

				// Tactile
    			Object s = m_tracer.addEventElement("tactile");
    			m_tracer.addSubelement(s, "here", m_tactileStimulations[8].getHexColor());
    			m_tracer.addSubelement(s, "rear", m_tactileStimulations[7].getHexColor());
    			m_tracer.addSubelement(s, "touch_6", m_tactileStimulations[6].getHexColor());
    			m_tracer.addSubelement(s, "touch_5", m_tactileStimulations[5].getHexColor());
    			m_tracer.addSubelement(s, "touch_4", m_tactileStimulations[4].getHexColor());
    			m_tracer.addSubelement(s, "touch_3", m_tactileStimulations[3].getHexColor());
    			m_tracer.addSubelement(s, "touch_2", m_tactileStimulations[2].getHexColor());
    			m_tracer.addSubelement(s, "touch_1", m_tactileStimulations[1].getHexColor());
    			m_tracer.addSubelement(s, "touch_0", m_tactileStimulations[0].getHexColor());
    			
    			// Local space memory
    			
    			m_spas.traceLocalSpace();
    		}
        }

		return primitiveSchema;    		
	}
	
	public IAct enactedAct(IAct act, int[][] stimuli) 
	{
		// If the intended act was null (during the first cycle), then the enacted act is null.
		IAct enactedAct = null;		

		// Sense the environment ===
		
		sense(stimuli);
		
		// Compute the enacted act == 
		
		if (act != null)
		{
			if (act.getSchema().getLabel().equals(">"))
				m_satisfaction = m_satisfaction + (m_status ? 20 : -100);
			else
				m_satisfaction = m_satisfaction + (m_status ? -10 : -20);
		
			enactedAct = m_imos.addInteraction(act.getSchema().getLabel(), m_stimuli, m_satisfaction);

			if (m_tracer != null) 
				m_tracer.addEventElement("primitive_enacted_schema", act.getSchema().getLabel());
		}
		return enactedAct;
	}
	
	public void sense(int[][] stimuli)
	{
		// Vision =====
		
		m_visualStimulations = new Stimulation[Ernest.RESOLUTION_RETINA];
		for (int i = 0; i < Ernest.RESOLUTION_RETINA; i++)
		{
			m_visualStimulations[i] = m_spas.addStimulation(Ernest.MODALITY_VISUAL, stimuli[i][1] * 65536 + stimuli[i][2] * 256 + stimuli[i][3]);
			float angle = (float) (- 11 * Math.PI/24 + i * Math.PI/12); 
			Vector3f pos = new Vector3f((float) Math.cos(angle) * stimuli[i][0] / Ernest.INT_FACTOR, (float) Math.sin(angle) * stimuli[i][0] / Ernest.INT_FACTOR, 0);
			m_visualStimulations[i].setPosition(pos);
		}
		
		// Touch =====
		
		m_tactileStimulations = new IStimulation[9];
		
		for (int i = 0; i < 9; i++)
			m_tactileStimulations[i] = m_spas.addStimulation(Ernest.MODALITY_TACTILE, stimuli[i][9]);
			
		// Kinematic ====
		
		//IStimulation kinematicStimulation;
		
		m_kinematicStimulation = m_spas.addStimulation(Ernest.STIMULATION_KINEMATIC, stimuli[1][8]);

		// Taste =====
		
		//IStimulation 
		m_gustatoryStimulation = m_spas.addStimulation(Ernest.STIMULATION_GUSTATORY, stimuli[0][8]); 

	}
	
	/**
	 * Generate the dynamic stimuli from the impact in the local space memory.
	 * The stimuli come from: 
	 * - The kinematic feature.
	 * - The variation in attractiveness and in direction of the object of interest. 
	 * @param act The enacted act.
	 */
	private boolean setFinalFeedback(IObservation previousObservation, IObservation newObservation)
	{
		boolean endInteraction = false;
		
		int   newAttractiveness = newObservation.getAttractiveness();
		float newDirection = newObservation.getDirection();
		
		String finalFeedback = "";
		
		float minFovea =  - (float)Math.PI / 4 + 0.01f;
		float maxFovea =    (float)Math.PI / 4 - 0.01f;
		
		// Incorrect ending
		// If the initial instantaneous feedback is not that expected then the interaction is ended.
		if (m_interactionTimer >= INTERACTION_ONGOING && !m_expectedInstantaneousFeedback.equals(m_initialObservation.getInstantaneousFeedback()))
			endInteraction = true;
		
		// Correct ending
		// If the current instantaneous feedback is no longer correct
		if (m_interactionTimer > INTERACTION_ONGOING )
		{
			if (m_primitiveAct != null && m_primitiveAct.getSchema().getLabel().equals(">"))
			//if (m_primitiveAct.getSchema().getLabel().equals(">"))
			{
				if (newObservation.getPosition().dot(newObservation.getSpeed()) > 0 ||
					Math.abs(newObservation.getDirection()) > Math.PI/4)
					// getting away
					endInteraction = true;
				else if (newObservation.getSpeed().length() < MINIMUM_SPEED)
					// stopped
					endInteraction = true;
			}
			else
			{
				if (newObservation.getSpeed().x < 0 ||
						Math.abs(newObservation.getDirection()) > Math.PI/8)
					endInteraction = true;
				else if (newObservation.getSpeed().length() < MINIMUM_SPEED)
					// stopped
					endInteraction = true;
			}
		}
			
		
		// The final feedback is constructed from the initial instantaneous feedback and the ending condition.
		
		int satisfaction = 0;

		finalFeedback = m_initialObservation.getInstantaneousFeedback();

		if (newAttractiveness >= 0)
		{
			// Positive attractiveness
			{
				// Satisfaction
				if (finalFeedback.equals("-"))
					satisfaction = -100;
				if (finalFeedback.equals("+"))
					satisfaction = 20;

				// Direction
				if (!finalFeedback.equals(""))
				{
					if (newDirection <= minFovea)
						finalFeedback = "|" + finalFeedback;
					else if (newDirection >= maxFovea )
						finalFeedback = finalFeedback + "|";
				}		
			}
		}
		else
		{
			// Negative attractiveness (repulsion)
			// Satisfaction
			if (finalFeedback.equals("*"))
				satisfaction = -100;
			if (finalFeedback.equals("_"))
				satisfaction = 20;
			
			// Direction
			if (!finalFeedback.equals(""))
			{
				if (newDirection < -0.1f ) 
					finalFeedback = "|" + finalFeedback;
				else if (newDirection > 0.1f )
					finalFeedback = finalFeedback + "|";
			}		
		}
		
		// Gustatory
		
		if (newObservation.getGustatoryStimulation().getValue() != Ernest.STIMULATION_GUSTATORY_NOTHING)
		{
			finalFeedback = "e";
			satisfaction = 100;
		}
		
		// Kinematic
		
		m_status = (newObservation.getKinematicStimulation().getValue() != Ernest.STIMULATION_KINEMATIC_BUMP);
		
		m_stimuli = (m_status ? " " : "w") + finalFeedback;

		m_satisfaction = satisfaction;
		
		if (m_primitiveAct != null && m_primitiveAct.getSchema().getLabel().equals(">"))
			m_satisfaction = m_satisfaction + (m_status ? 20 : -100);
		else
			m_satisfaction = m_satisfaction + (m_status ? -10 : -20);

		m_visualStimuli = finalFeedback;
		
		return endInteraction;
	}
	
	/**
	 * Generate the instantaneous feedback that is computed from the instantaneous relative acceleration of the focus.
	 * @param previousObservation The observation made on the previous cycle.
	 * @param newObservation The current observation .
	 */
	private void setInstantaneousFeedback(IObservation previousObservation, IObservation newObservation)
	{
		String instantaneousFeedback = "";
		
		// Compute the speed of tactile places TODO change this
		if (newObservation.getSpeed().z == .01f)
		{
			Vector3f relativeSpeed = new Vector3f(newObservation.getPosition());
			relativeSpeed.sub(previousObservation.getPosition());
			
			Vector3f rotationSpeed = new Vector3f(- newObservation.getPosition().y, newObservation.getPosition().x, 0); // Orthogonal to the position vector.
			rotationSpeed.normalize();
			rotationSpeed.scale(- m_rotation);
			relativeSpeed.add(rotationSpeed);
			newObservation.setSpeed(relativeSpeed);
		}
		
		Vector3f relativeAcceleration = new Vector3f(newObservation.getSpeed());
		relativeAcceleration.sub(previousObservation.getSpeed());
		
		if (newObservation.getAttractiveness() >= 0)
		{
			// Positive attractiveness
			// Move forward
			if (m_primitiveAct != null && m_primitiveAct.getSchema().getLabel().equals(">"))
			{
				if (relativeAcceleration.dot(newObservation.getPosition()) < 0 &&
					Math.abs(newObservation.getDirection()) < Math.PI/4)
					// Closer
					instantaneousFeedback = "+";
				else
					// Farther
					instantaneousFeedback = "-";
			}
			else
			{
				if (relativeAcceleration.x > 0)
					// More frontwards
					instantaneousFeedback = "+";
				else
					// More backward
					instantaneousFeedback = "-";
			}
		}
		else
		{
			// Negative attractiveness (repulsion)
			
			if (previousObservation.getAttractiveness() >= 0)
				// A wall appeared with a part of it in front of Ernest
				instantaneousFeedback = "*";		
			else 
			{
				// aleady in front of a wall.
				if (m_primitiveAct != null && m_primitiveAct.getSchema().getLabel().equals(">"))
				{
					if (relativeAcceleration.dot(newObservation.getPosition()) <= 0)
						// Closer
						instantaneousFeedback = "*";
					else
						// Farther
						instantaneousFeedback = "_";
				}
				else
				{
					if (relativeAcceleration.x > 0)
						// More to front
						instantaneousFeedback = "*";
					else
						// More to the side
						instantaneousFeedback = "_";
				}
			}
		}	
		
		newObservation.setInstantaneousFeedback(instantaneousFeedback);
		
		// Detects the change of attention
		
		
	}
	
	public int impulsion(int intentionSchema) 
	{
		int impulsion = 0;
		
		if (intentionSchema == '>')
		{
			impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR);
//			if (m_observation.getDistance() < .5f)
//				impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR * .5f);
//			if (m_observation.getDistance() < 1.1f)
//				impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR * m_observation.getDistance());
//			else
//				impulsion = (int)(TRANSLATION_IMPULSION * Ernest.INT_FACTOR * 1.1f);
		}
		if (intentionSchema == '^' || intentionSchema == 'v' )
		{ 
			impulsion = (int)(ROTATION_IMPULSION * Ernest.INT_FACTOR);
//			if (Math.abs(m_observation.getDirection()) > Math.PI/8)
//				impulsion = (int)(ROTATION_IMPULSION * Ernest.INT_FACTOR * Math.abs(m_observation.getDirection()) / (Math.PI/4));
//			if (impulsion > 2 * ROTATION_IMPULSION * Ernest.INT_FACTOR)
//				impulsion = (int)(2 * ROTATION_IMPULSION * Ernest.INT_FACTOR);
			
			//return (int)(Math.abs(m_observation.getPlace().getDirection()) * 1000);
		}
		return impulsion;
	}
}