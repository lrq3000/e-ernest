package spas;

import java.util.ArrayList;
import java.util.List;

import javax.vecmath.Vector3f;

import imos.IAct;
import ernest.Ernest;
import ernest.ITracer;

/**
 * The spatial system.
 * Maintains the local space map and the persistence memory.
 * @author Olivier
 */
public class Spas implements ISpas 
{
	
	/** The Tracer. */
	private ITracer m_tracer = null; 

	/** Ernest's internal clock  */
	private int m_clock;

	/** Ernest's persistence momory  */
	private PersistenceMemory m_persistenceMemory = new PersistenceMemory();
	
	/** Ernest's local space memory  */
	private LocalSpaceMemory m_localSpaceMemory = new LocalSpaceMemory();
	
	/** The visual stimulation in front of Ernest  */
	IStimulation m_frontVisualStimulation;

	/** The list of saliences generated by Ernest's sensory system  */
	List<ISalience> m_salienceList = new ArrayList<ISalience>();

	/** The anticipated local map  */
	ISalience m_focusSalience = null;
	
	/** The anticipated local map  */
	IBundle m_focusBundle = null;
	
	IStimulation m_kinematicStimulation = Ernest.STIMULATION_KINEMATIC_FORWARD;
	IStimulation m_gustatoryStimulation = Ernest.STIMULATION_GUSTATORY_NOTHING;
	
	public void setTracer(ITracer tracer) 
	{
		m_tracer = tracer;
		m_persistenceMemory.setTracer(tracer);
	}

	public IObservation step(IAct act, IStimulation[] visualStimulations,
			IStimulation[] tactileStimulations, IStimulation kinematicStimulation,
			IStimulation gustatoryStimulation) 
	{
		// Tick the clock
		m_persistenceMemory.tick();
		m_clock++;
		
		m_gustatoryStimulation = gustatoryStimulation;
		m_kinematicStimulation = kinematicStimulation;

		// Update the local space memory
		m_localSpaceMemory.update(act, kinematicStimulation);
		
		// Construct the list of saliences. 
		
		List<ISalience> saliences = new ArrayList<ISalience>();
		saliences = getSaliences(visualStimulations, tactileStimulations); 	// Saliences computed by Ernest.
		//saliences = m_salienceList; 							// Saliences provided by VacuumSG.

		// Set the attractiveness of saliences.
		
		setSaliencesAttractiveness(saliences);

		// Find the most attractive or the most repulsive salience in the list (abs value) (There is at least a wall)
		
		m_focusSalience = null;
		m_focusBundle = null;
		int maxAttractiveness = 0;
		float direction = 0;
		for (ISalience salience : saliences)
			if (Math.abs(salience.getAttractiveness()) > Math.abs(maxAttractiveness))
			{
				maxAttractiveness = salience.getAttractiveness();
				direction = salience.getDirection();
				m_focusSalience = salience;
				m_focusBundle = salience.getBundle();
			}

		// Create new bundles and place them in the local space memory.
		
		createBundles(m_frontVisualStimulation, tactileStimulations[3] , m_kinematicStimulation, m_gustatoryStimulation);
		
		// Adjust the local space memory according to the tactile simulations.
		
		adjustLocalSpaceMemory(tactileStimulations);
		
		// Construct the new observation.
		
		IObservation observation = new Observation();
		observation.setGustatory(gustatoryStimulation);
		observation.setKinematic(kinematicStimulation);
		observation.setAttractiveness(maxAttractiveness);
		observation.setDirection(direction);
		
		return observation;
	}
	
	public IStimulation addStimulation(int type, int value) 
	{
		return m_persistenceMemory.addStimulation(type, value);
	}

	public int getValue(int i, int j)
	{
		if (i == 1 && j == 0 && Ernest.STIMULATION_KINEMATIC_BUMP.equals(m_kinematicStimulation))
			return Ernest.STIMULATION_KINEMATIC_BUMP.getValue();
		else if (i == 1 && j == 1 && Ernest.STIMULATION_GUSTATORY_FISH.equals(m_gustatoryStimulation))
			return Ernest.STIMULATION_GUSTATORY_FISH.getValue();
		else
		{
			Vector3f position = new Vector3f(1 - j, 1 - i, 0);
			return m_localSpaceMemory.getValue(position);
		}
	}

	/**
	 * Generate the list of the saliences from the sensory stimulations.
	 * @param visualStimulations The visual stimulations.
	 * @param tactileCortex The tactile stimulations.
	 * @return The salience list.
	 */
	private List<ISalience> getSaliences(IStimulation[] visualStimulations,
				IStimulation[] tactileStimulations)
	   {
		// Visual saliences ====

		List<ISalience> saliences = new ArrayList<ISalience>(Ernest.RESOLUTION_COLLICULUS);

		m_frontVisualStimulation = null;
		IStimulation stimulation = visualStimulations[0];
		int span = 1;
		float theta = - 11 * (float)Math.PI / 24; 
		float sumDirection = theta;
		float spanf = (float)Math.PI / 12;
		for (int i = 1 ; i < Ernest.RESOLUTION_RETINA; i++)
		{
			theta += (float)Math.PI / 12;
			if (visualStimulations[i].equals(stimulation))
			{
				// measure the salience span and average direction
				span++;
                sumDirection += theta;
                spanf += (float)Math.PI / 12;
			}
			else 
			{	
				// Record the previous salience
				ISalience salience = new Salience(stimulation.getValue(), Ernest.MODALITY_VISUAL, sumDirection / span, 1, spanf);
				saliences.add(salience);
				if (i > 6 && span >= i - 5 && span > 2)
					m_frontVisualStimulation = stimulation;
				// look for the next salience
				stimulation = visualStimulations[i];
				span = 1;
				spanf = (float)Math.PI / 12;
				sumDirection = theta;
			}
		}
		// record the last salience
		ISalience last = new Salience(stimulation.getValue(),  Ernest.MODALITY_VISUAL, sumDirection / span, 1, spanf);
		saliences.add(last);
		if (span > 6)
			m_frontVisualStimulation = stimulation;
	
		// Tactile saliences =====
		
		IStimulation tactileStimulation = tactileStimulations[0];
		span = 1;
		theta = - 3 * (float)Math.PI / 4; 
		sumDirection = theta;
		spanf = (float)Math.PI / 4;
		for (int i = 1 ; i < 7; i++)
		{
			theta += (float)Math.PI / 4;
			if (tactileStimulations[i].equals(tactileStimulation))
			{
				// measure the salience span and average direction
				span++;
                sumDirection += theta;
                spanf += (float)Math.PI / 4;
			}
			else 
			{	
				// Record the previous salience
				ISalience salience = new Salience(tactileStimulation.getValue(), Ernest.MODALITY_TACTILE, sumDirection / span, 1, spanf);
				saliences.add(salience);
				// look for the next salience
				tactileStimulation = tactileStimulations[i];
				span = 1;
				spanf = (float)Math.PI / 4;
				sumDirection = theta;
			}
		}
		// record the last salience
		ISalience salience = new Salience(tactileStimulation.getValue(),  Ernest.MODALITY_TACTILE, sumDirection / span, 1, spanf);
		saliences.add(salience);

	   return saliences;
   }

	/**
	 * Get the list of saliences computed from the "colliculus".
	 * @param salienceList The list of saliences provided by VacuumSG.
	 */
	public void setSalienceList(ArrayList<ISalience> salienceList)
	{
		m_salienceList = salienceList;
	}
	
	/**
	 * Set the attractiveness of the saliences in the list of saliences.
	 */
	private void setSaliencesAttractiveness(List<ISalience> salienceList)
	{
		for (ISalience salience : salienceList)
		{
			if (salience.getModality() == Ernest.MODALITY_VISUAL)
			{
				// Attractiveness of visual saliences.
				IStimulation stimulation = new Stimulation(Ernest.MODALITY_VISUAL, salience.getValue());
				IBundle b = m_persistenceMemory.seeBundle(stimulation);
				salience.setBundle(b);
				salience.setAttractiveness(m_persistenceMemory.attractiveness(stimulation) + (int)(5 * salience.getSpan() / ((float)Math.PI / 12)));
			}
			else if (salience.isFrontal() && salience.getValue()== Ernest.STIMULATION_TOUCH_WALL.getValue())// != Ernest.STIMULATION_TOUCH_EMPTY.getValue())
			{
				// Attractiveness of touching a wall.
				IStimulation stimulation = new Stimulation(Ernest.MODALITY_TACTILE, salience.getValue());
				IBundle b = m_persistenceMemory.touchBundle(stimulation);
				if (b != null)
				{
					salience.setBundle(b);
					salience.setAttractiveness(b.getAttractiveness(m_clock));
					salience.setValue(b.getValue());
				}
				else
					salience.setAttractiveness(Ernest.ATTRACTIVENESS_OF_HARD);
			}
			else if (salience.getValue()== Ernest.STIMULATION_TOUCH_FISH.getValue())// != Ernest.STIMULATION_TOUCH_EMPTY.getValue())
			{
				// Attractiveness of touching a fish.
				IStimulation stimulation = new Stimulation(Ernest.MODALITY_TACTILE, salience.getValue());
				IBundle b = m_persistenceMemory.touchBundle(stimulation);
				if (b != null)
				{
					salience.setBundle(b);
					salience.setAttractiveness(b.getAttractiveness(m_clock));
					salience.setValue(b.getValue());
					// Place the bundle in the local space memory
					m_localSpaceMemory.addLocation(b, salience.getPosition());					
				}
//				else
//					salience.setAttractiveness(Ernest.ATTRACTIVENESS_OF_HARD);
			}
		}
	}
	
	/**
	 * Create new bundles based on cooccurrences of stimulations.
	 * Place the new bundles in the local space map.
	 * @param frontVisualStimulation The visual stimulation in front of Ernest.
	 * @param frontTactileStimulation The tactile stimulation in front of Ernest.
	 * @param kinematicStimulation The kinematic stimulation.
	 * @param gustatoryStimulation The gustatory stimulation.
	 */
	private void createBundles(IStimulation frontVisualStimulation, IStimulation frontTactileStimulation, 
			IStimulation kinematicStimulation, IStimulation gustatoryStimulation)
	{
		// Associate the tactile stimulation with the kinematic stimulation.

		IBundle frontBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_AHEAD);
		IBundle hereBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_HERE);
		
		if (kinematicStimulation.equals(Ernest.STIMULATION_KINEMATIC_BUMP) )
		{
			if (frontBundle == null)
			{
				if (frontTactileStimulation.equals(Ernest.STIMULATION_TOUCH_WALL))
				{
					if (frontVisualStimulation == null)
					{
						IBundle b = m_persistenceMemory.createTactoKinematicBundle(frontTactileStimulation, Ernest.STIMULATION_KINEMATIC_BUMP);
						m_localSpaceMemory.addLocation(b, LocalSpaceMemory.DIRECTION_AHEAD);
					}
					else
					{
						IBundle b = m_persistenceMemory.addBundle(m_frontVisualStimulation, frontTactileStimulation, Ernest.STIMULATION_KINEMATIC_BUMP, Ernest.STIMULATION_GUSTATORY_NOTHING);
						m_localSpaceMemory.addLocation(b, LocalSpaceMemory.DIRECTION_AHEAD);
					}
				}
			}
			else if (frontBundle.getTactileStimulation().equals(Ernest.STIMULATION_TOUCH_WALL))
				m_persistenceMemory.addKinematicStimulation(frontBundle, m_kinematicStimulation);
		}

		// Associate the tactile stimulation with the gustatory stimulation
		
		if (gustatoryStimulation.equals(Ernest.STIMULATION_GUSTATORY_FISH))
		{
			// Discrete environment. The fish bundle is the hereBundle.
			if (hereBundle == null)
			{
				IBundle b = m_persistenceMemory.createTactoGustatoryBundle(Ernest.STIMULATION_TOUCH_FISH, Ernest.STIMULATION_GUSTATORY_FISH);
			}
			else if (hereBundle.getTactileStimulation().equals(Ernest.STIMULATION_TOUCH_FISH))
			{
				m_persistenceMemory.addGustatoryStimulation(hereBundle, gustatoryStimulation);
				m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_HERE);
			}
			
			// Continuous environment. The fish bundle is the frontBundle
			if (frontBundle == null) // Continuous environment. 
			{
				IBundle b = m_persistenceMemory.createTactoGustatoryBundle(Ernest.STIMULATION_TOUCH_FISH, Ernest.STIMULATION_GUSTATORY_FISH);
			}
			else if (frontBundle.getTactileStimulation().equals(Ernest.STIMULATION_TOUCH_FISH))
			{
				m_persistenceMemory.addGustatoryStimulation(frontBundle, gustatoryStimulation);
				m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_AHEAD);
			}
		}
		
//		// If the current stimulation does not match the anticipated local map then the local map is cleared.
//		// TODO The criteria to decide whether the matching is correct or incorrect need to be learned ! 
//
//		if (hereBundle != null && hereBundle.getTactileStimulation().equals(Ernest.STIMULATION_TOUCH_WALL))
//			m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_HERE);
//		if (frontBundle != null && !frontBundle.getTactileStimulation().equals(frontTactileStimulation))
//			m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_AHEAD);

		// Associate the visual stimulation with the tactile stimulation.
		
		if (frontVisualStimulation != null )
		{
			if (frontBundle == null)
			{
				if (!frontTactileStimulation.equals(Ernest.STIMULATION_TOUCH_EMPTY))		
				{
					IBundle bundle = m_persistenceMemory.createVisioTactileBundle(frontVisualStimulation, frontTactileStimulation);
					m_localSpaceMemory.addLocation(bundle, LocalSpaceMemory.DIRECTION_AHEAD);
				}
			}
			else
			{
//				m_persistenceMemory.addVisualStimulation(frontBundle, frontVisualStimulation);
				//m_localSpaceMemory.addLocation(frontBundle, LocalSpaceMemory.DIRECTION_AHEAD);
			}
		}
		frontVisualStimulation = null;	
		
		// Trace.
		if (m_tracer != null) 
		{
			Object e = m_tracer.addEventElement("focus");
			m_tracer.addSubelement(e, "salience", m_focusSalience.getHexColor());
			
			if (m_focusBundle != null)
				m_tracer.addSubelement(e, "bundle", m_focusBundle.getHexColor());

			// Trace the local space memory
			m_localSpaceMemory.Trace(m_tracer);
		}
	}
	
	/**
	 * Remove the bundles in local space memory that are not consistent with the tactile stimuli.
     * TODO The criteria to decide whether the matching is correct or incorrect need to be learned ! 
	 * @param tactileStimulations The tactile stimuli.
	 */
	private void adjustLocalSpaceMemory(IStimulation[] tactileStimulations)
	{

		for (IStimulation s : tactileStimulations)
		{
			Vector3f position = s.getPosition();
			IBundle b = m_localSpaceMemory.getBundle(position);
			if (b != null && b.getTactileStimulation().getValue() != s.getValue())
				m_localSpaceMemory.clearLocation(position);
		}
		
		
//		IBundle hereBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_HERE);
//		IBundle frontBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_AHEAD);
//		
//		// The here bundle cannot be a wall
//		if (hereBundle != null && hereBundle.getTactileStimulation().equals(Ernest.STIMULATION_TOUCH_WALL))
//			m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_HERE);
//		
//		// The front bundle's stimulation must correspond to
//		if (frontBundle != null && !frontBundle.getTactileStimulation().equals(tactileStimulations[3]))
//			m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_AHEAD);
		
	}
}
