package spas;

import imos.IAct;

import java.util.ArrayList;
import java.util.List;

import javax.media.j3d.Transform3D;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3f;
import ernest.Ernest;
import ernest.ITracer;

/**
 * The spatial system.
 * Maintains the local space map and the persistence memory.
 * @author Olivier
 */
public class Spas implements ISpas 
{
	
	/** The Tracer. */
	private ITracer m_tracer = null; 
	
//	public static int PLACE_BACKGROUND = -1;
//	public static int PLACE_SEE = 0;
//	public static int PLACE_TOUCH = 1;
//	public static int PLACE_FOCUS = 10;
//	public static int PLACE_BUMP = 11;
//	public static int PLACE_EAT  = 12;
//	public static int PLACE_CUDDLE = 13;
//	public static int PLACE_PRIMITIVE = 14;
//	public static int PLACE_COMPOSITE = 15;
//	public static int PLACE_INTERMEDIARY = 16;
//	public static int PLACE_PHENOMENON = 18;
//	public static int PLACE_COPRESENCE = 19;
	
//	public static int PLACE_EVOKE_PHENOMENON = 17;
//	public static int PLACE_SIMULATION = 20;
//	public static int PLACE_UNKNOWN = 21;
//	public static int PLACE_AFFORD = 22;
	
	/** A list of all the bundles ever identified. */
	public List<IBundle> m_bundles = new ArrayList<IBundle>(10);
	
	/** Ernest's local space memory  */
	private ISpatialMemory m_localSpaceMemory = new LocalSpaceMemory();
	
	/** The list of saliences generated by Ernest's sensory system  */
	//List<IPlace> m_placeList = new ArrayList<IPlace>();
	
	IObservation m_observation;
	
	/** The clock of the spatial system. (updated on each update cycle as opposed to IMOS) */
	private int m_clock;

	public void setTracer(ITracer tracer) 
	{
		m_tracer = tracer;
	}

	/**
	 * The main method of the Spatial System that is called on each interaction cycle.
	 * Maintain the local space memory.
	 * Construct compresences.
	 * @param transformation The transformation in spatial memory.
	 */
	public void track(Transform3D transformation) 
	{
		m_localSpaceMemory.copresence(this);
		
		if (m_tracer != null) m_localSpaceMemory.trace(m_tracer);

		m_localSpaceMemory.transform(transformation);		
	}

//	public void step(IObservation observation)//, ArrayList<IPlace> places) 
//	{		
//
//		//m_observation = observation;
//		
//		// Create and maintain phenomenon places from interaction places. 		
//		m_localSpaceMemory.copresence(this);
//		
//		if (m_tracer != null) m_localSpaceMemory.trace(m_tracer);
//
//	}
	
	public int getValue(int i, int j)
	{
		Point3f position = new Point3f(1 - j, 1 - i, 0);
		if (m_localSpaceMemory != null)
			return m_localSpaceMemory.getValue(position);
		else
			return 0xFFFFFF;
	}

	public int getAttention()
	{
		int attention;
		if (m_observation == null || m_observation.getFocusPlace() == null)
			attention = Ernest.UNANIMATED_COLOR;
		else
			attention = m_observation.getFocusPlace().getBundle().getValue();

		return attention;
	}
	
	/**
	 * Set the list of saliences from the list provided by VacuumSG.
	 * @param salienceList The list of saliences provided by VacuumSG.
	 */
//	public void setPlaceList(List<IPlace> placeList)
//	{
//		m_placeList = placeList;
//	}
		
	public ArrayList<IPlace> getPlaceList()
	{
		return m_localSpaceMemory.getPlaceList();
	}

	public IPlace addPlace(Point3f position, int type) 
	{
		IPlace place = m_localSpaceMemory.addPlace(position, type);
//		place.setFirstPosition(position);
//		place.setSecondPosition(position);
		place.setType(type);
		place.setUpdateCount(m_clock);
		
		return place;
	}

	public IBundle addBundle(IAct firstAct, IAct secondAct) 
	{
		IBundle bundle = new Bundle(firstAct, secondAct);
		bundle.setValue(firstAct.getColor());
		
		int i = m_bundles.indexOf(bundle);
		if (i == -1)
		{
			m_bundles.add(bundle);
			if (m_tracer != null) {
				bundle.trace(m_tracer, "bundle");
			}
		}
		else 
			// The bundle already exists: return a pointer to it.
			bundle =  m_bundles.get(i);
		
		return bundle;
	}

	public int getClock() 
	{
		return m_clock;
	}

	public void tick() 
	{
		m_clock++;
		m_localSpaceMemory.tick();
	}

//	public boolean checkAct(IAct act) 
//	{
//		// TODO Auto-generated method stub
//		return false;
//	}

	public int getValue(Point3f position) 
	{
		return m_localSpaceMemory.getValue(position);
	}

//	public IPlace getPlace(Vector3f position) 
//	{
//		return m_localSpaceMemory.getPlace(position);
//	}
	
	public ISpatialMemory getSpatialMemory()
	{
		return m_localSpaceMemory;
	}

	/**
	 * Returns the first bundle found that contains this act.
	 * @param act The act to check.
	 * @return The bundle that match this act.
	 */
//	public IBundle evokeBundle(IAct act)
//	{
//		for (IBundle bundle : m_bundles)
//		{
//			if (bundle.hasAct(act))
//				return bundle;
//			// presuppose the value of phenomena
//			//if (bundle.getValue() == act.getPhenomenon())
//			//	return bundle;
//				
//		}
//		return null;
//	}

	/**
	 * Returns the list of compresences that afford this act.
	 * @param act The act to check.
	 * @return The list of compresences that match this act.
	 */
	public ArrayList<IBundle> evokeCompresences(IAct act)
	{
		ArrayList<IBundle> compresences = new ArrayList<IBundle>();

		for (IBundle bundle : m_bundles)
			if (bundle.afford(act))
				compresences.add(bundle);

		return compresences;
	}
}
