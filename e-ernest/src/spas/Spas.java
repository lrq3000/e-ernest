package spas;

import java.util.ArrayList;
import java.util.List;

import javax.vecmath.Vector3f;

import imos.IAct;
import ernest.Ernest;
import ernest.ITracer;

/**
 * The spatial system.
 * Maintains the local space map and the persistence memory.
 * @author Olivier
 */
public class Spas implements ISpas 
{
	
	/** The Tracer. */
	private ITracer m_tracer = null; 

	/** Ernest's persistence momory  */
	private PersistenceMemory m_persistenceMemory = new PersistenceMemory();
	
	/** Ernest's local space memory  */
	private LocalSpaceMemory m_localSpaceMemory = new LocalSpaceMemory();
	
	/** The visual stimulation in front of Ernest  */
	//ISalience m_frontVisualSalience;

	/** The list of saliences generated by Ernest's sensory system  */
	List<ISalience> m_salienceList = new ArrayList<ISalience>();

	IStimulation m_kinematicStimulation = Ernest.STIMULATION_KINEMATIC_FORWARD;
	IStimulation m_gustatoryStimulation = Ernest.STIMULATION_GUSTATORY_NOTHING;
	
	public void setTracer(ITracer tracer) 
	{
		m_tracer = tracer;
		m_persistenceMemory.setTracer(tracer);
	}

	public IObservation step(IAct act, IStimulation[] visualStimulations,
			IStimulation[] tactileStimulations, IStimulation kinematicStimulation,
			IStimulation gustatoryStimulation) 
	{
		// Tick the clock
		m_persistenceMemory.tick();
		
		m_gustatoryStimulation = gustatoryStimulation;
		m_kinematicStimulation = kinematicStimulation;

		// Update the local space memory
		m_localSpaceMemory.update(act, kinematicStimulation);
		
		// Construct the list of saliences. 
		
		List<ISalience> saliences = new ArrayList<ISalience>();
		saliences = getSaliences(visualStimulations, tactileStimulations); 	// Saliences computed by Ernest.
		//saliences = m_salienceList; 							            // Saliences provided by VacuumSG.

		// Create new bundles and place them in the local space memory.
		
		createBundles(saliences, tactileStimulations[3].getValue() , m_kinematicStimulation.getValue(), m_gustatoryStimulation.getValue());
		
		// Clean up the local space memory according to the tactile simulations.
		
		adjustLocalSpaceMemory(tactileStimulations);
		
		// Set the attractiveness of saliences.
		// TODO construct a list of places of interest whether they are visible or not. 
		
		setSaliencesAttractiveness(saliences);
		//List<ISalience> attractiveSaliences = attractiveSaliences(saliences);

		// Find the most attractive or the most repulsive salience in the list (abs value) (There is at least a wall)
		
		int maxAttractiveness = 0;
		float direction = 0;
		ISalience focusSalience = null;
		//for (ISalience salience : attractiveSaliences)
		for (ISalience salience : saliences)
		{
			if (Math.abs(salience.getAttractiveness()) > Math.abs(maxAttractiveness))
			{
				maxAttractiveness = salience.getAttractiveness();
				direction = salience.getDirection();
				focusSalience = salience;
			}
		}
		
		// Trace the focus salience and the local space memory.
		if (m_tracer != null) 
		{
			Object e = m_tracer.addEventElement("focus");
			m_tracer.addSubelement(e, "salience", focusSalience.getHexColor());
			m_localSpaceMemory.Trace(m_tracer);
		}
		
		// Return the new observation.
		
		IObservation observation = new Observation();
		observation.setGustatory(gustatoryStimulation);
		observation.setKinematic(kinematicStimulation);
		observation.setAttractiveness(maxAttractiveness);
		observation.setDirection(direction);
		
		return observation;
	}
	
	public IStimulation addStimulation(int type, int value) 
	{
		return m_persistenceMemory.addStimulation(type, value);
	}

	public int getValue(int i, int j)
	{
		if (i == 1 && j == 0 && Ernest.STIMULATION_KINEMATIC_BUMP.equals(m_kinematicStimulation))
			return Ernest.STIMULATION_KINEMATIC_BUMP.getValue();
		else if (i == 1 && j == 1 && Ernest.STIMULATION_GUSTATORY_FISH.equals(m_gustatoryStimulation))
			return Ernest.STIMULATION_GUSTATORY_FISH.getValue();
		else
		{
			Vector3f position = new Vector3f(1 - j, 1 - i, 0);
			return m_localSpaceMemory.getValue(position);
		}
	}

	/**
	 * Generate the list of the saliences from the sensory stimulations.
	 * @param visualStimulations The visual stimulations.
	 * @param tactileStimulations The tactile stimulations.
	 * @return The salience list.
	 */
	private List<ISalience> getSaliences(IStimulation[] visualStimulations,
				IStimulation[] tactileStimulations)
	   {
		// Visual saliences ====

		List<ISalience> saliences = new ArrayList<ISalience>(Ernest.RESOLUTION_COLLICULUS);

		IStimulation stimulation = visualStimulations[0];
		int span = 1;
		float theta = - 11 * (float)Math.PI / 24; 
		float sumDirection = theta;
		float spanf = (float)Math.PI / 12;
		for (int i = 1 ; i < Ernest.RESOLUTION_RETINA; i++)
		{
			theta += (float)Math.PI / 12;
			if (visualStimulations[i].equals(stimulation))
			{
				// measure the salience span and average direction
				span++;
                sumDirection += theta;
                spanf += (float)Math.PI / 12;
			}
			else 
			{	
				// Record the previous salience
				ISalience salience = new Salience(stimulation.getValue(), Ernest.MODALITY_VISUAL, sumDirection / span, 1, spanf);
				saliences.add(salience);
//				if (i > 6 && span >= i - 5 && span > 2)
//					m_frontVisualSalience = salience;
				// look for the next salience
				stimulation = visualStimulations[i];
				span = 1;
				spanf = (float)Math.PI / 12;
				sumDirection = theta;
			}
		}
		// record the last salience
		ISalience last = new Salience(stimulation.getValue(),  Ernest.MODALITY_VISUAL, sumDirection / span, 1, spanf);
		saliences.add(last);
//		if (span > 6)
//			m_frontVisualSalience = last;
	
		// Tactile saliences =====
		
		IStimulation tactileStimulation = tactileStimulations[0];
		span = 1;
		theta = - 3 * (float)Math.PI / 4; 
		sumDirection = theta;
		spanf = (float)Math.PI / 4;
		for (int i = 1 ; i < 7; i++)
		{
			theta += (float)Math.PI / 4;
			if (tactileStimulations[i].equals(tactileStimulation))
			{
				// measure the salience span and average direction
				span++;
                sumDirection += theta;
                spanf += (float)Math.PI / 4;
			}
			else 
			{	
				// Record the previous salience
				ISalience salience = new Salience(tactileStimulation.getValue(), Ernest.MODALITY_TACTILE, sumDirection / span, 1, spanf);
				saliences.add(salience);
				// look for the next salience
				tactileStimulation = tactileStimulations[i];
				span = 1;
				spanf = (float)Math.PI / 4;
				sumDirection = theta;
			}
		}
		// record the last salience
		ISalience salience = new Salience(tactileStimulation.getValue(),  Ernest.MODALITY_TACTILE, sumDirection / span, 1, spanf);
		saliences.add(salience);
		
		// Saliences from Local space memory ====
		

	   return saliences;
   }

	/**
	 * Set the list of saliences from the list provided by VacuumSG.
	 * @param salienceList The list of saliences provided by VacuumSG.
	 */
	public void setSalienceList(ArrayList<ISalience> salienceList)
	{
		m_salienceList = salienceList;
	}
	
	/**
	 * Set the attractiveness of the saliences in the list of saliences.
	 */
	private void setSaliencesAttractiveness(List<ISalience> salienceList)
	{
		int clock = m_persistenceMemory.getClock();
		for (ISalience salience : salienceList)
		{
			if (salience.getModality() == Ernest.MODALITY_VISUAL)
			{
				// Attractiveness of visual saliences.
				IBundle b = m_persistenceMemory.seeBundle(salience.getValue());
				salience.setAttractiveness(m_persistenceMemory.visualAttractiveness(salience.getValue()) + (int)(5 * salience.getSpan() / ((float)Math.PI / 12)));
			}
			else if (salience.isFrontal() && salience.getValue()== Ernest.STIMULATION_TOUCH_WALL.getValue())// != Ernest.STIMULATION_TOUCH_EMPTY.getValue())
			{
				// Attractiveness of touching a wall.
				IBundle b = m_persistenceMemory.touchBundle(salience.getValue());
				if (b != null)
				{
					//salience.setBundle(b);
					salience.setAttractiveness(b.getAttractiveness(clock));
					salience.setValue(b.getValue());
				}
				else
					salience.setAttractiveness(Ernest.ATTRACTIVENESS_OF_HARD);
			}
			else if (salience.getValue()== Ernest.STIMULATION_TOUCH_FISH.getValue())// != Ernest.STIMULATION_TOUCH_EMPTY.getValue())
			{
				// Attractiveness of touching a fish.
				IBundle b = m_persistenceMemory.touchBundle(salience.getValue());
				if (b != null)
				{
					//salience.setBundle(b);
					salience.setAttractiveness(b.getAttractiveness(clock));
					salience.setValue(b.getValue());
					// Place the bundle in the local space memory
					m_localSpaceMemory.addPlace(b, salience.getPosition());					
				}
//				else
//					salience.setAttractiveness(Ernest.ATTRACTIVENESS_OF_HARD);
			}
		}
		
		// Add saliences from bundles in the local space memory.
		for (IPlace place : m_localSpaceMemory.getPlaces())
		{
			if (place.getBundle().getGustatoryValue() == Ernest.STIMULATION_GUSTATORY_FISH.getValue())
			{
				ISalience attractiveSalience = new Salience(place.getBundle().getVisualValue(), Ernest.MODALITY_VISUAL, place.getPosition(), Ernest.ATTRACTIVENESS_OF_FISH - 10);
				salienceList.add(attractiveSalience);
			}
		}
	}
	
	/**
	 * Set the attractiveness of the saliences in the list of saliences.
	 */
	private List<ISalience> attractiveSaliences(List<ISalience> salienceList)
	{
		List<ISalience> attractiveSaliences = new ArrayList<ISalience>();

		int clock = m_persistenceMemory.getClock();
		for (ISalience salience : salienceList)
		{
			if (salience.getModality() == Ernest.MODALITY_VISUAL)
			{
				// Attractiveness of visual saliences.
				IBundle b = m_persistenceMemory.seeBundle(salience.getValue());
				//salience.setAttractiveness(m_persistenceMemory.visualAttractiveness(salience.getValue()) + (int)(5 * salience.getSpan() / ((float)Math.PI / 12)));
				int attractiveness = m_persistenceMemory.visualAttractiveness(salience.getValue()) + (int)(5 * salience.getSpan() / ((float)Math.PI / 12));
				ISalience attractiveSalience = new Salience(salience.getValue(), salience.getModality(), salience.getPosition(), attractiveness);
				attractiveSaliences.add(attractiveSalience);
			}
			else if (salience.isFrontal() && salience.getValue()== Ernest.STIMULATION_TOUCH_WALL.getValue())
			{
				// Attractiveness of touching a wall.
				IBundle b = m_persistenceMemory.touchBundle(salience.getValue());
				if (b != null)
				{
					//salience.setBundle(b);
//					salience.setAttractiveness(b.getAttractiveness(clock));
//					salience.setValue(b.getValue());
					ISalience attractiveSalience = new Salience(b.getValue(), salience.getModality(), salience.getPosition(), b.getAttractiveness(clock));
					attractiveSaliences.add(attractiveSalience);
				}
				else
				{
					//salience.setAttractiveness(Ernest.ATTRACTIVENESS_OF_HARD);
					ISalience attractiveSalience = new Salience(salience.getValue(), salience.getModality(), salience.getPosition(), Ernest.ATTRACTIVENESS_OF_HARD);
					attractiveSaliences.add(attractiveSalience);
				}
			}
			else if (salience.getValue()== Ernest.STIMULATION_TOUCH_FISH.getValue())
			{
				// Attractiveness of touching a fish.
				IBundle b = m_persistenceMemory.touchBundle(salience.getValue());
				if (b != null)
				{
//					salience.setAttractiveness(b.getAttractiveness(clock));
//					salience.setValue(b.getValue());
					ISalience attractiveSalience = new Salience(b.getValue(), salience.getModality(), salience.getPosition(), b.getAttractiveness(clock));
					attractiveSaliences.add(attractiveSalience);
					// Place the bundle in the local space memory
					m_localSpaceMemory.addPlace(b, salience.getPosition());					
				}
			}
		}
		return attractiveSaliences;
	}
	
	/**
	 * Create new bundles based on cooccurrences of stimulations.
	 * Place the new bundles in the local space map.
	 * @param frontVisualStimulation The visual stimulation in front of Ernest.
	 * @param frontTactileStimulation The tactile stimulation in front of Ernest.
	 * @param kinematicStimulation The kinematic stimulation.
	 * @param gustatoryStimulation The gustatory stimulation.
	 */
	private void createBundles(List<ISalience> saliences, int frontTactileValue, int kinematicValue, int gustatoryValue)
	{
		// Find the visual salience in front of Ernest.
		ISalience frontVisualSalience = null;
		for (ISalience salience : saliences)
			if (salience.isFrontal() && salience.getModality() == Ernest.MODALITY_VISUAL && salience.getSpan() > Math.PI/6+0.01f )
				frontVisualSalience = salience;
		
		// Associate the tactile stimulation with the kinematic stimulation.

		IBundle frontBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_AHEAD);
		IBundle hereBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_HERE);
		
		if (kinematicValue == Ernest.STIMULATION_KINEMATIC_BUMP.getValue())
		{
			if (frontBundle == null)
			{
				if (frontTactileValue == Ernest.STIMULATION_TOUCH_WALL.getValue())
				{
					if (frontVisualSalience == null)
					{
						IBundle b = m_persistenceMemory.createTactoKinematicBundle(frontTactileValue, Ernest.STIMULATION_KINEMATIC_BUMP.getValue());
						m_localSpaceMemory.addPlace(b, LocalSpaceMemory.DIRECTION_AHEAD);
					}
					else
					{
						IBundle b = m_persistenceMemory.addBundle(frontVisualSalience.getValue(), frontTactileValue, Ernest.STIMULATION_KINEMATIC_BUMP.getValue(), Ernest.STIMULATION_GUSTATORY_NOTHING.getValue());
						m_localSpaceMemory.addPlace(b, LocalSpaceMemory.DIRECTION_AHEAD);
					}
				}
			}
			else if (frontBundle.getTactileValue() == Ernest.STIMULATION_TOUCH_WALL.getValue())
				m_persistenceMemory.addKinematicValue(frontBundle, kinematicValue);
		}

		// Associate the tactile stimulation with the gustatory stimulation
		
		if (gustatoryValue == Ernest.STIMULATION_GUSTATORY_FISH.getValue())
		{
			// Discrete environment. The fish bundle is the hereBundle.
			if (hereBundle == null)
			{
				m_persistenceMemory.createTactoGustatoryBundle(Ernest.STIMULATION_TOUCH_FISH.getValue(), Ernest.STIMULATION_GUSTATORY_FISH.getValue());
			}
			else if (hereBundle.getTactileValue() == Ernest.STIMULATION_TOUCH_FISH.getValue())
			{
				m_persistenceMemory.addGustatoryValue(hereBundle, gustatoryValue);
				m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_HERE);
			}
			
			// Continuous environment. The fish bundle is the frontBundle
			if (frontBundle == null) // Continuous environment. 
			{
				m_persistenceMemory.createTactoGustatoryBundle(Ernest.STIMULATION_TOUCH_FISH.getValue(), Ernest.STIMULATION_GUSTATORY_FISH.getValue());
			}
			else if (frontBundle.getTactileValue() == Ernest.STIMULATION_TOUCH_FISH.getValue())
			{
				m_persistenceMemory.addGustatoryValue(frontBundle, gustatoryValue);
				m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_AHEAD);
			}
		}
		
		// Associate the visual stimulation with the tactile stimulation.
		
		if (frontVisualSalience != null )
		{
			if (frontBundle == null)
			{
				if (frontTactileValue != Ernest.STIMULATION_TOUCH_EMPTY.getValue())		
				{
					IBundle bundle = m_persistenceMemory.createVisioTactileBundle(frontVisualSalience.getValue(), frontTactileValue);
					m_localSpaceMemory.addPlace(bundle, LocalSpaceMemory.DIRECTION_AHEAD);
				}
			}
			else
			{
//				m_persistenceMemory.addVisualStimulation(frontBundle, frontVisualStimulation);
				//m_localSpaceMemory.addLocation(frontBundle, LocalSpaceMemory.DIRECTION_AHEAD);
			}
		}
//		frontVisualStimulation = null;	
		
	}
	
	/**
	 * Remove the bundles in local space memory that are not consistent with the tactile stimuli.
     * TODO The criteria to decide whether the matching is correct or incorrect need to be learned ! 
	 * @param tactileStimulations The tactile stimuli.
	 */
	private void adjustLocalSpaceMemory(IStimulation[] tactileStimulations)
	{

		// Check the front 
		IBundle frontBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_AHEAD);
		if (frontBundle != null && frontBundle.getTactileValue() != tactileStimulations[3].getValue())
			m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_AHEAD);

		// Check here
		IBundle hereBundle = m_localSpaceMemory.getBundle(LocalSpaceMemory.DIRECTION_HERE);
		if (hereBundle != null && hereBundle.getTactileValue() != tactileStimulations[8].getValue())
			m_localSpaceMemory.clearLocation(LocalSpaceMemory.DIRECTION_HERE);
	}
}
